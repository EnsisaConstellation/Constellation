<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Hazelcast Documentation</title><link rel="stylesheet" type="text/css" href="./docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><meta name="keywords" content="hazelcast, distributed, cache, distributed cache, cluster, data grid, in-memory data grid"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Hazelcast Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>Hazelcast Documentation</h1></div><div><h2 class="subtitle">version 2.4</h2></div><div><p class="copyright">Copyright &copy; 2012 Hazel Bilisim Ltd. Sti.</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d0e15"></a><p>Permission to use, copy, modify and distribute
                this document for any purpose and
                without fee is hereby granted in perpetuity, provided that the above
                copyright notice and this paragraph appear in all copies.
            </p></div></div><div><p class="pubdate">17 October 2012 </p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#Introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GettingStarted">1.1. Getting Started (Tutorial)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#DDS">2. Distributed Data Structures</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Queue">2.1. Distributed Queue</a></span></dt><dt><span class="sect1"><a href="#Topic">2.2. Distributed Topic</a></span></dt><dt><span class="sect1"><a href="#Map">2.3. Distributed Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MapBackup">2.3.1. Backups</a></span></dt><dt><span class="sect2"><a href="#MapEviction">2.3.2. Eviction</a></span></dt><dt><span class="sect2"><a href="#MapPersistence">2.3.3. Persistence</a></span></dt><dt><span class="sect2"><a href="#MapQuery">2.3.4. Query</a></span></dt><dt><span class="sect2"><a href="#MapNearCache">2.3.5. Near Cache</a></span></dt><dt><span class="sect2"><a href="#MapEntry">2.3.6. Entry Statistics</a></span></dt><dt><span class="sect2"><a href="#MapIndex">2.3.7. Indexing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MultiMap">2.4. Distributed MultiMap</a></span></dt><dt><span class="sect1"><a href="#Set">2.5. Distributed Set</a></span></dt><dt><span class="sect1"><a href="#List">2.6. Distributed List</a></span></dt><dt><span class="sect1"><a href="#Lock">2.7. Distributed Lock</a></span></dt><dt><span class="sect1"><a href="#Events">2.8. Distributed Events</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ElasticMemory">3. Elastic Memory
            <sup>(Enterprise Edition Only)</sup>
        </a></span></dt><dt><span class="chapter"><a href="#Security">4. Security
            <sup>(Enterprise Edition Only)</sup>
        </a></span></dt><dd><dl><dt><span class="sect1"><a href="#Credentials">4.1. Credentials</a></span></dt><dt><span class="sect1"><a href="#ClusterLoginModule">4.2. ClusterLoginModule</a></span></dt><dt><span class="sect1"><a href="#MemberSecurity">4.3. Cluster Member Security</a></span></dt><dt><span class="sect1"><a href="#ClientSecurity">4.4. Native Client Security</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1373">4.4.1. Authentication</a></span></dt><dt><span class="sect2"><a href="#d0e1409">4.4.2. Authorization</a></span></dt><dt><span class="sect2"><a href="#d0e1468">4.4.3. Permissions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#DataAffinity">5. Data Affinity</a></span></dt><dt><span class="chapter"><a href="#JMX">6. Monitoring with JMX</a></span></dt><dt><span class="chapter"><a href="#ClusterUtilities">7. Cluster Utilities</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ClusterInterface">7.1. Cluster Interface</a></span></dt><dt><span class="sect1"><a href="#IdGenerator">7.2. Cluster-wide Id Generator</a></span></dt><dt><span class="sect1"><a href="#LiteMember">7.3. LiteMember</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Transactions">8. Transactions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TransactionInterface">8.1. Transaction Interface</a></span></dt><dt><span class="sect1"><a href="#JEEIntegration">8.2. J2EE Integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JEEIntegrationConfig">8.2.1. Resource Adapter Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationGlassfishSample">8.2.2. Sample Glassfish v3 Web Application Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationJBossSample">8.2.3. Sample JBoss Web Application Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ExecutorService">9. Distributed Executor Service</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DistributedExecution">9.1. Distributed Execution</a></span></dt><dt><span class="sect1"><a href="#ExecutionCancellation">9.2. Execution Cancellation</a></span></dt><dt><span class="sect1"><a href="#ExecutionCallback">9.3. Execution Callback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#HttpSessionClustering">10. Http Session Clustering with HazelcastWM</a></span></dt><dt><span class="chapter"><a href="#WanReplication">11. WAN Replication</a></span></dt><dt><span class="chapter"><a href="#Config">12. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigGroup">12.1. Creating Separate Clusters</a></span></dt><dt><span class="sect1"><a href="#NetworkConfig">12.2. Network Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConfigTcpIp">12.2.1. Configuring TCP/IP Cluster</a></span></dt><dt><span class="sect2"><a href="#ConfigSpecifyInterfaces">12.2.2. Specifying Network Interfaces</a></span></dt><dt><span class="sect2"><a href="#EC2AutoDiscovery">12.2.3. EC2 Auto Discovery</a></span></dt><dt><span class="sect2"><a href="#NetworkPartitioning">12.2.4. Network Partitioning (Split-Brain Syndrome)</a></span></dt><dt><span class="sect2"><a href="#SSL">12.2.5. SSL</a></span></dt><dt><span class="sect2"><a href="#Encryption">12.2.6. Encryption</a></span></dt><dt><span class="sect2"><a href="#SocketInterceptor">12.2.7. Socket Interceptor</a></span></dt><dt><span class="sect2"><a href="#IPv6">12.2.8. IPv6 Support</a></span></dt><dt><span class="sect2"><a href="#OutboundPorts">12.2.9. Restricting Outbound Ports</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PartitionGroupConfig">12.3. Partition Group Configuration</a></span></dt><dt><span class="sect1"><a href="#ListenerConfig">12.4. Listener Configurations</a></span></dt><dt><span class="sect1"><a href="#WildcardConfiguration">12.5. Wildcard Configuration</a></span></dt><dt><span class="sect1"><a href="#ConfigurationProperties">12.6. Advanced Configuration Properties</a></span></dt><dt><span class="sect1"><a href="#Logging">12.7. Logging Configuration</a></span></dt><dt><span class="sect1"><a href="#EnterpriseConfig">12.8. Setting License Key <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="chapter"><a href="#HibernateSecondLevelCache">13. Hibernate Second Level Cache</a></span></dt><dt><span class="chapter"><a href="#SpringIntegration">14. Spring Integration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SpringConfiguration">14.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#SpringContext">14.2. Spring Managed Context</a></span></dt><dt><span class="sect1"><a href="#SpringCache">14.3. Spring Cache</a></span></dt><dt><span class="sect1"><a href="#SpringHibernate">14.4. Hibernate 2nd Level Cache Config</a></span></dt><dt><span class="sect1"><a href="#SpringJPA">14.5. Spring Data - JPA</a></span></dt><dt><span class="sect1"><a href="#SpringMongoDB">14.6. Spring Data - MongoDB</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Clients">15. Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#NativeClient">15.1. Native Client</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JavaClient">15.1.1. Java Client</a></span></dt><dt><span class="sect2"><a href="#CSharpClient">15.1.2. CSharp Client <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="sect1"><a href="#MemcacheClient">15.2. Memcache Client</a></span></dt><dt><span class="sect1"><a href="#RestClient">15.3. Rest Client</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Internals">16. Internals</a></span></dt><dd><dl><dt><span class="sect1"><a href="#InternalsSerialization">16.1. Internals 2: Serialization</a></span></dt><dt><span class="sect1"><a href="#InternalsClusterMembership">16.2. Internals 3: Cluster Membership</a></span></dt><dt><span class="sect1"><a href="#InternalsDistributedMap">16.3. Internals 4: Distributed Map</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ManagementCenter">17. Management Center</a></span></dt><dd><dl><dt><span class="sect1"><a href="#MC_Intro">17.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_Installation">17.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#MC_UserAdministration">17.1.2. User Administration</a></span></dt><dt><span class="sect2"><a href="#MC_ToolOverview">17.1.3. Tool Overview</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Maps">17.2. Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MapMonitoring">17.2.1. Monitoring Maps</a></span></dt><dt><span class="sect2"><a href="#MC_MapBrowser">17.2.2. Map Browser</a></span></dt><dt><span class="sect2"><a href="#MC_MapConfiguration">17.2.3. Map Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Queues">17.3. Queues</a></span></dt><dt><span class="sect1"><a href="#MC_Topics">17.4. Topics</a></span></dt><dt><span class="sect1"><a href="#MC_Members">17.5. Members</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MemberMonitoring">17.5.1. Monitoring</a></span></dt><dt><span class="sect2"><a href="#MC_MemberOperations">17.5.2. Operations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Logs">17.6. System Logs</a></span></dt><dt><span class="sect1"><a href="#MC_Scripting">17.7. Scripting</a></span></dt><dt><span class="sect1"><a href="#MC_TimeTravel">17.8. Time Travel</a></span></dt><dt><span class="sect1"><a href="#MC_Console">17.9. Console</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Miscellaneous">18. Miscellaneous</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CommonGotchas">18.1. Common Gotchas</a></span></dt><dt><span class="sect1"><a href="#ClusterTestHowTo">18.2. Testing Cluster</a></span></dt><dt><span class="sect1"><a href="#Todo">18.3. Planned Features</a></span></dt><dt><span class="sect1"><a href="#ReleaseNotes">18.4. Release Notes</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>12.1. <a href="#d0e3447">Properties Table</a></dt></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="Introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#GettingStarted">1.1. Getting Started (Tutorial)</a></span></dt></dl></div><p>
    Hazelcast is a clustering and highly scalable data distribution platform for Java. Hazelcast helps architects and
    developers to easily design and develop faster, highly scalable and reliable applications for their businesses.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed implementations of
                <code class="literal">java.util.{Queue, Set, List, Map}</code>
            </p></li><li class="listitem"><p>Distributed implementation of
                <code class="literal">java.util.concurrent.ExecutorService</code>
            </p></li><li class="listitem"><p>Distributed implementation of
                <code class="literal">java.util.concurrency.locks.Lock</code>
            </p></li><li class="listitem"><p>Distributed
                <code class="literal">Topic</code>
                for publish/subscribe messaging
            </p></li><li class="listitem"><p>Transaction support and J2EE container integration via JCA
            </p></li><li class="listitem"><p>Distributed listeners and events
            </p></li><li class="listitem"><p>Support for cluster info and membership events
            </p></li><li class="listitem"><p>Dynamic HTTP session clustering
            </p></li><li class="listitem"><p>Dynamic clustering
            </p></li><li class="listitem"><p>Dynamic scaling to hundreds of servers
            </p></li><li class="listitem"><p>Dynamic partitioning with backups
            </p></li><li class="listitem"><p>Dynamic fail-over
            </p></li></ul></div><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Super simple to use; include a single jar
            </p></li><li class="listitem"><p>Super fast; thousands of operations per sec.
            </p></li><li class="listitem"><p>Super small; less than a MB
            </p></li><li class="listitem"><p>Super efficient; very nice to CPU and RAM
            </p></li></ul></div><p>
    To install Hazelcast:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download hazelcast-_version_.zip from
                <a class="link" href="http://www.hazelcast.com" target="_top">www.hazelcast.com</a>
            </p></li><li class="listitem"><p>Unzip hazelcast-_version_.zip file
            </p></li><li class="listitem"><p>Add hazelcast.jar file into your classpath
            </p></li></ul></div><p>
    Hazelcast is pure Java. JVMs that are running Hazelcast will dynamically cluster. Although by default Hazelcast will
    use multicast for discovery, it can also be configured to only use TCP/IP for environments where multicast is not
    available or preferred (<a class="link" href="#ConfigTcpIp" title="12.2.1.&nbsp;Configuring TCP/IP Cluster">Click here for more info</a>). Communication among
    cluster members is always
    TCP/IP with Java NIO beauty. Default configuration comes with 1 backup so if one node fails, no data will be lost.
    It is as simple as using<code class="literal">java.util.{Queue, Set, List, Map}</code>. Just add the hazelcast.jar into your
    classpath and start coding.
</p><div class="sect1" title="1.1.&nbsp;Getting Started (Tutorial)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GettingStarted"></a>1.1.&nbsp;Getting Started (Tutorial)</h2></div></div></div><p>
        In this short tutorial, we will create simple Java application using Hazelcast distributed map and queue.
        Then we will run our application twice to have two nodes (JVMs) clustered and finalize this tutorial
        with connecting to our cluster from another Java application by using Hazelcast Native Java Client API.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download the latest
                    <a class="link" href="http://www.hazelcast.com/downloads.jsp" target="_top">Hazelcast zip</a>.
                </p></li><li class="listitem"><p>Unzip it and add the
                    <code class="literal">lib/hazelcast.jar</code>
                    to your class path.
                </p></li><li class="listitem"><p>Create a Java class and import Hazelcast libraries.</p></li><li class="listitem"><p>Following code will start the first node and create and use
                    <code class="literal">customers</code>
                    map and queue.
                    </p><pre class="programlisting">
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Queue;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> GettingStarted {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Map&lt;Integer, String&gt; mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
        mapCustomers.put(<span class="hl-number">1</span>, <font font-style="normal" color="#008000">"Joe"</font>);
        mapCustomers.put(<span class="hl-number">2</span>, <font font-style="normal" color="#008000">"Ali"</font>);
        mapCustomers.put(<span class="hl-number">3</span>, <font font-style="normal" color="#008000">"Avi"</font>);

        System.out.println(<font font-style="normal" color="#008000">"Customer with key 1: "</font>+ mapCustomers.get(<span class="hl-number">1</span>));
        System.out.println(<font font-style="normal" color="#008000">"Map Size:"</font> + mapCustomers.size());

        Queue&lt;String&gt; queueCustomers = Hazelcast.getQueue(<font font-style="normal" color="#008000">"customers"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Tom"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Mary"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Jane"</font>);
        System.out.println(<font font-style="normal" color="#008000">"First customer: "</font> + queueCustomers.poll());
        System.out.println(<font font-style="normal" color="#008000">"Second customer: "</font>+ queueCustomers.peek());
        System.out.println(<font font-style="normal" color="#008000">"Queue size: "</font> + queueCustomers.size());
    }
}
</pre><p>
                </p></li><li class="listitem"><p>Run this class second time to get the second node started.</p></li><li class="listitem"><p>Have you seen they formed a cluster? You should see something like this:
                    </p><pre class="programlisting">
Members [2] {
	Member [127.0.0.1:5701]
	Member [127.0.0.1:5702] this
}
                            </pre><p>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Connecting Hazelcast Cluster with Java Client API</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Besides
                    <code class="literal">hazelcast.jar</code>
                    you should also add
                    <code class="literal">hazelcast-client.jar</code>
                    to your classpath.
                </p></li><li class="listitem"><p>Following code will start a Hazelcast Client, connect to our two node cluster
                    and print the size of our
                    <code class="literal">customers</code>
                    map.
                    </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.test;

<strong class="hl-keyword">import</strong> com.hazelcast.client.ClientConfig;
<strong class="hl-keyword">import</strong> com.hazelcast.client.HazelcastClient;
<strong class="hl-keyword">import</strong> com.hazelcast.core.HazelcastInstance;
<strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> GettingStartedClient {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
        clientConfig.addAddress(<font font-style="normal" color="#008000">"127.0.0.1:5701"</font>);
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
        IMap map = client.getMap(<font font-style="normal" color="#008000">"customers"</font>);
        System.out.println(<font font-style="normal" color="#008000">"Map Size:"</font> + map.size());
    }
}
</pre><p>
                </p></li><li class="listitem"><p>When you run it, you will see the client properly connects to the cluster and print the map
                    size as 3.
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>What is Next?</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can browse
                    <a class="link" href="http://www.hazelcast.com/docs.jsp" target="_top">documentation</a>
                    and resources for detailed features and examples.
                </p></li><li class="listitem"><p>You can email your questions to Hazelcast
                    <a class="link" href="http://groups.google.com/group/hazelcast" target="_top">mail group</a>.
                </p></li><li class="listitem"><p>You can browse Hazelcast
                    <a class="link" href="http://code.google.com/p/hazelcast/source/browse/#svn/trunk" target="_top">source
                        code</a>.
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Distributed Data Structures"><div class="titlepage"><div><div><h2 class="title"><a name="DDS"></a>Chapter&nbsp;2.&nbsp;Distributed Data Structures</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Queue">2.1. Distributed Queue</a></span></dt><dt><span class="sect1"><a href="#Topic">2.2. Distributed Topic</a></span></dt><dt><span class="sect1"><a href="#Map">2.3. Distributed Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MapBackup">2.3.1. Backups</a></span></dt><dt><span class="sect2"><a href="#MapEviction">2.3.2. Eviction</a></span></dt><dt><span class="sect2"><a href="#MapPersistence">2.3.3. Persistence</a></span></dt><dt><span class="sect2"><a href="#MapQuery">2.3.4. Query</a></span></dt><dt><span class="sect2"><a href="#MapNearCache">2.3.5. Near Cache</a></span></dt><dt><span class="sect2"><a href="#MapEntry">2.3.6. Entry Statistics</a></span></dt><dt><span class="sect2"><a href="#MapIndex">2.3.7. Indexing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MultiMap">2.4. Distributed MultiMap</a></span></dt><dt><span class="sect1"><a href="#Set">2.5. Distributed Set</a></span></dt><dt><span class="sect1"><a href="#List">2.6. Distributed List</a></span></dt><dt><span class="sect1"><a href="#Lock">2.7. Distributed Lock</a></span></dt><dt><span class="sect1"><a href="#Events">2.8. Distributed Events</a></span></dt></dl></div><p>
    Common Features of all Hazelcast Data Structures:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Data in the cluster is almost evenly distributed (partitioned) across all nodes.
                So each node carries ~ (1/n
                <code class="literal">*</code>
                total-data) + backups , n being the
                number of nodes in the cluster.
            </p></li><li class="listitem"><p>If a member goes down, its backup replica that also holds the same data, will
                dynamically redistribute the data including the ownership and locks on them to
                remaining live nodes. As a result, no data will get lost.
            </p></li><li class="listitem"><p>When a new node joins the cluster, new node takes ownership(responsibility) and
                load of -some- of the entire data in the cluster. Eventually the new node will carry
                almost (1/n
                <code class="literal">*</code>
                total-data) + backups and becomes the new partition
                reducing the load on others.
            </p></li><li class="listitem"><p>There is no single cluster master or something that can cause single point of
                failure. Every node in the cluster has equal rights and responsibilities. No-one is
                superior. And no dependency on external 'server' or 'master' kind of concept.
            </p></li></ul></div><p>
    Here is how you can retrieve existing data structure instances (map, queue, set,
    lock, topic, etc.) and how you can listen for instance events to get notified when an instance
    is created or destroyed.
    </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Instance;
<strong class="hl-keyword">import</strong> com.hazelcast.core.InstanceEvent;
<strong class="hl-keyword">import</strong> com.hazelcast.core.InstanceListener;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> InstanceListener {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Sample sample = <strong class="hl-keyword">new</strong> Sample();

        Hazelcast.addInstanceListener(sample);

        Collection&lt;Instance&gt; instances = Hazelcast.getInstances();
        <strong class="hl-keyword">for</strong> (Instance instance : instances) {
           System.out.println(instance.getInstanceType() + <font font-style="normal" color="#008000">","</font> + instance.getId());
        }
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> instanceCreated(InstanceEvent event) {
       Instance instance = event.getInstance();
       System.out.println(<font font-style="normal" color="#008000">"Created "</font> + instance.getInstanceType() + <font font-style="normal" color="#008000">","</font> + instance.getId());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> instanceDestroyed(InstanceEvent event) {
        Instance instance = event.getInstance();
        System.out.println(<font font-style="normal" color="#008000">"Destroyed "</font> + instance.getInstanceType() + <font font-style="normal" color="#008000">","</font> + instance.getId());
    }
}</pre><p>
</p><div class="sect1" title="2.1.&nbsp;Distributed Queue"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Queue"></a>2.1.&nbsp;Distributed Queue</h2></div></div></div><p>Hazelcast distributed queue is an implementation
        of<code class="literal">java.util.concurrent.BlockingQueue</code>.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.BlockingQueue;
<strong class="hl-keyword">import</strong> java.util.concurrent.TimeUnit;

BlockingQueue&lt;MyTask&gt; q = Hazelcast.getQueue(<font font-style="normal" color="#008000">"tasks"</font>);
q.put(<strong class="hl-keyword">new</strong> MyTask());
MyTask task = q.take();

<strong class="hl-keyword">boolean</strong> offered = q.offer(<strong class="hl-keyword">new</strong> MyTask(), <span class="hl-number">10</span>, TimeUnit.SECONDS);
task = q.poll (<span class="hl-number">5</span>, TimeUnit.SECONDS);
<strong class="hl-keyword">if</strong> (task != null) {
    <em class="hl-comment" style="color: silver">//process task</em>
}
</pre><p>
        If you have 10 million tasks in your "tasks" queue and you are running that
        code over 10 JVMs (or servers), then each server carries 1 million task objects (plus
        backups). FIFO ordering will apply to all queue operations cluster-wide. User objects (such
        as
        <code class="literal">MyTask</code>
        in the example above), that are (en/de)queued have to
        be<code class="literal">Serializable</code>. Maximum capacity per JVM and the TTL (Time to Live)
        for a queue can be configured.
        </p><p>
            Distributed queues are backed by distributed maps. Thus,
            queues can have custom backup counts and persistent storage. Hazelcast will generate
            cluster-wide unique id for each element in the queue.
        </p><p>
        Sample configuration:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"tasks"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum size of the queue. When a JVM's local queue size reaches the maximum,
            all put/offer operations will get blocked until the queue size
            of the JVM goes down below the maximum.
            Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-size-per-jvm&gt;</font>10000<font font-style="bold" color="#0A1777">&lt;/max-size-per-jvm&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!--
            Name of the map configuration that will be used for the backing distributed
            map for this queue.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backing-map-ref&gt;</font>queue-map<font font-style="bold" color="#0A1777">&lt;/backing-map-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/queue&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"queue-map"</font><font font-style="bold" color="#0A1777">&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>

            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.your,company.storage.DBMapStore<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>

            <font font-style="bold" color="#0A1777">&lt;write-delay-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/write-delay-seconds&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;/map-store&gt;</font>

        ...

    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        If the backing map has no
        <code class="literal">map-store</code>
        defined then your
        distributed queue will be in-memory only. If the backing map has a
        <code class="literal">map-store</code>
        defined then Hazelcast will call your
        <code class="literal">MapStore</code>
        implementation to persist queue elements. Even if you reboot
        your cluster Hazelcast will rebuild the queue with its content. When implementing a
        <code class="literal">MapStore</code>
        for the backing map, note that type of the
        <code class="literal">key</code>
        is always
        <code class="literal">Long</code>
        and values are the elements you place into the queue. So make
        sure
        <code class="literal">MapStore.loadAllKeys</code>
        returns
        <code class="literal">Set&lt;Long&gt;</code>
        for
        instance.
    </p><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="12.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.2.&nbsp;Distributed Topic"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Topic"></a>2.2.&nbsp;Distributed Topic</h2></div></div></div><p>Hazelcast provides distribution mechanism for publishing messages that are delivered to
        multiple subscribers which is also known as publish/subscribe (pub/sub) messaging model.
        Publish and subscriptions are cluster-wide. When a member subscribes for a topic, it is
        actually registering for messages published by any member in the cluster, including the new
        members joined after you added the listener. Messages are ordered, meaning,
        listeners(subscribers) will process the messages in the order they are actually published.
        If cluster member M publishes messages m1, m2, m3...mn to a topic T, then Hazelcast makes
        sure that all of the subscribers of topic T will receive and process m1, m2, m3...mn in
        order. Therefore there is only single thread invoking onMessage. The user shouldn't keep the
        thread busy and preferably dispatch it via an Executor. This will increase the performance
        of the topic
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Topic;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.MessageListener;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> MessageListener&lt;MyEvent&gt; {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Sample sample = <strong class="hl-keyword">new</strong> Sample();
        ITopic topic = Hazelcast.getTopic (<font font-style="normal" color="#008000">"default"</font>);
        topic.addMessageListener(sample);
        topic.publish (<strong class="hl-keyword">new</strong> MyEvent());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(MyEvent myEvent) {
        System.out.println(<font font-style="normal" color="#008000">"Message received = "</font> + myEvent.toString());
        <strong class="hl-keyword">if</strong> (myEvent.isHeavyweight()) {
            messageExecutor.execute(<strong class="hl-keyword">new</strong> Runnable() {
                <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> run() {
                    doHeavyweightStuff(myEvent);
                }
            });
        }
    }

    <em class="hl-comment" style="color: silver">// ...</em>

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">final</strong> Executor messageExecutor = Executors.newSingleThreadExecutor();
}

</pre><p>
    </p><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="12.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.3.&nbsp;Distributed Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Map"></a>2.3.&nbsp;Distributed Map</h2></div></div></div><p>Just like queue and set, Hazelcast will partition your map entries; and almost evenly
        distribute onto all Hazelcast members. Distributed maps have 1 backup (replica-count) by
        default so that if a member goes down, we don't lose data. Backup operations are synchronous
        so when a
        <code class="literal">map.put(key, value)</code>
        returns, it is guaranteed that the entry is
        replicated to one other node. For the reads, it is also guaranteed that
        <code class="literal">map.get(key)</code>
        returns the latest value of the entry. Consistency is
        strictly enforced.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Collection;

Map&lt;String, Customer&gt; mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
mapCustomers.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Joe"</font>, <font font-style="normal" color="#008000">"Smith"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"2"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Ali"</font>, <font font-style="normal" color="#008000">"Selam"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"3"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Avi"</font>, <font font-style="normal" color="#008000">"Noyan"</font>));

Collection&lt;Customer&gt; colCustomers = mapCustomers.values();
<strong class="hl-keyword">for</strong> (Customer customer : colCustomers) {
    <em class="hl-comment" style="color: silver">// process customer</em>
}
</pre><p>
        <code class="literal">Hazelcast.getMap()</code>
        actually returns
        <code class="literal">com.hazelcast.core.IMap</code>
        which extends
        <code class="literal">java.util.concurrent.ConcurrentMap</code>
        interface. So methods like
        <code class="literal">ConcurrentMap.putIfAbsent(key,value)</code>
        and
        <code class="literal">ConcurrentMap.replace(key,value)</code>
        can be used on distributed map as
        shown in the example below.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.ConcurrentMap;

Customer getCustomer (String id) {
    ConcurrentMap&lt;String, Customer&gt; map = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    Customer customer = map.get(id);
    <strong class="hl-keyword">if</strong> (customer == null) {
        customer = <strong class="hl-keyword">new</strong> Customer (id);
        customer = map.putIfAbsent(id, customer);
    }
    <strong class="hl-keyword">return</strong> customer;
}               

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> updateCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> (map.replace(customer.getId(), customer) != null);            
}
                
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> removeCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> map.remove(customer.getId(), customer) );           
}                                  
        
</pre><p>
        All
        <code class="literal">ConcurrentMap</code>
        operations such as
        <code class="literal">put</code>
        and
        <code class="literal">remove</code>
        might wait if the key is locked by another thread in the local
        or remote JVM, but they will eventually return with success.
        <code class="literal">ConcurrentMap</code>
        operations never
        throw<code class="literal">java.util.ConcurrentModificationException</code>.
    </p><p>Also see:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="#InternalsDistributedMap" title="16.3.&nbsp;Internals 4: Distributed Map">Distributed Map internals</a>.</p></li><li class="listitem"><p><a class="link" href="#DataAffinity" title="Chapter&nbsp;5.&nbsp;Data Affinity">Data Affinity</a>.</p></li><li class="listitem"><p><a class="link" href="#WildcardConfiguration" title="12.5.&nbsp;Wildcard Configuration">Map Configuration with wildcards.</a>.</p></li></ul></div><p>
    </p><div class="sect2" title="2.3.1.&nbsp;Backups"><div class="titlepage"><div><div><h3 class="title"><a name="MapBackup"></a>2.3.1.&nbsp;Backups</h3></div></div></div><p>Hazelcast will distribute map entries onto multiple JVMs (cluster members). Each JVM
        holds some portion of the data but we don't want to lose data when a member JVM crashes.
        To provide data-safety, Hazelcast allows you to specify the number of backup copies you
        want to have. That way data on a JVM will be copied onto other JVM(s). Hazelcast supports both
        <code class="literal">sync</code> and <code class="literal">async</code> backups.
        <code class="literal">Sync</code> backups block operations until backups are successfully copied to
        backups nodes (or deleted from backup nodes in case of remove)
        and acknowledgements are received. In contrast, <code class="literal">async</code> backups do not block
        operations, they are fire &amp; forget and do not require acknowledgements.
        By default, Hazelcast will have one sync backup copy.
        If backup count &gt;= 1, then each member will carry both owned entries and backup copies of other
        member(s). So for the <code class="literal">map.get(key)</code> call, it is possible that calling member has backup
        copy of that key but by default, <code class="literal">map.get(key)</code> will always read the
        value from the actual owner of the key for consistency. It is possible to enable backup
        reads by changing the configuration. Enabling backup reads will give you greater performance.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of sync-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Number of async-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;async-backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/async-backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Can we read the local backup entries? Default value is false for
            strong consistency. Being able to read backup data will give you
            greater performance.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;read-backup-data&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/read-backup-data&gt;</font>

        ...
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p></div><div class="sect2" title="2.3.2.&nbsp;Eviction"><div class="titlepage"><div><div><h3 class="title"><a name="MapEviction"></a>2.3.2.&nbsp;Eviction</h3></div></div></div><p>Hazelcast also supports policy based eviction for distributed map. Currently supported
        eviction policies are LRU (Least Recently Used) and LFU (Least Frequently Used). This
        feature enables Hazelcast to be used as a distributed cache. If
        <code class="literal">time-to-live-seconds</code>
        is not 0 then entries older than
        <code class="literal">time-to-live-seconds</code>
        value will get evicted, regardless of the
        eviction policy set. Here is a sample configuration for eviction:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay in the map. Entries that are
            older than &lt;time-to-live-seconds&gt; and not updated for &lt;time-to-live-seconds&gt;
            will get automatically evicted from the map.
            Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay idle in the map. Entries that are
            idle(not touched) for more than &lt;max-idle-seconds&gt; will get
            automatically evicted from the map.
            Entry is touched if get, put or containsKey is called.
            Any integer between 0 and Integer.MAX_VALUE.
            0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Valid values are:
            NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
            LRU  (Least Recently Used),
            LFU  (Least Frequently Used).
            NONE is the default.
            Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply. 
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum size of the map. When max size is reached,
            map is evicted based on the policy defined.
            Any integer between 0 and Integer.MAX_VALUE. 0 means
            Integer.MAX_VALUE. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"cluster_wide_map_size"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            When max. size is reached, specified percentage of
            the map will be evicted. Any integer between 0 and 100.
            If 25 is set for example, 25% of the entries will
            get evicted.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-percentage&gt;</font>25<font font-style="bold" color="#0A1777">&lt;/eviction-percentage&gt;</font>
       <em class="hl-comment" style="color: silver">&lt;!--
            Specifies when eviction will be started. Default value is 3. 
           So every 3 (+up to 5 for performance reasons) seconds 
           eviction will be kicked of. Eviction is costly operation, setting 
           this number too low, can decrease the performance. 
       --&gt;</em>
      <font font-style="bold" color="#0A1777">&lt;eviction-delay-seconds&gt;</font>3<font font-style="bold" color="#0A1777">&lt;/eviction-delay-seconds&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="bold"><strong>Max-Size Policies</strong></span>
    </p><p>
        There are 5 defined policies can be used in max-size configuration.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="bold"><strong>cluster_wide_map_size:</strong></span> Cluster-wide total max map size (default policy).
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"cluster_wide_map_size"</font><font font-style="bold" color="#0A1777">&gt;</font>50000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>map_size_per_jvm:</strong></span>  Max map size per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"map_size_per_jvm"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>partitions_wide_map_size:</strong></span> Partitions (default 271) wide max map size.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"partitions_wide_map_size"</font><font font-style="bold" color="#0A1777">&gt;</font>27100<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>used_heap_size:</strong></span> Max used heap size in MB (mega-bytes) per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"used_heap_size"</font><font font-style="bold" color="#0A1777">&gt;</font>4096<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>used_heap_percentage:</strong></span> Max used heap size percentage per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"used_heap_percentage"</font><font font-style="bold" color="#0A1777">&gt;</font>75<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.3.3.&nbsp;Persistence"><div class="titlepage"><div><div><h3 class="title"><a name="MapPersistence"></a>2.3.3.&nbsp;Persistence</h3></div></div></div><p>Hazelcast allows you to load and store the distributed map entries from/to a
        persistent datastore such as relational database. If a loader implementation is
        provided, when
        <code class="literal">get(key)</code>
        is called, if the map entry doesn't exist
        in-memory then Hazelcast will call your loader implementation to load the entry from a
        datastore. If a store implementation is provided, when
        <code class="literal">put(key,value)</code>
        is called, Hazelcast will call your store implementation to store the entry into a
        datastore. Hazelcast can call your implementation to store the entries synchronously
        (write-through) with no-delay or asynchronously (write-behind) with delay and it is
        defined by the
        <code class="literal">write-delay-seconds</code>
        value in the configuration.
    </p><p>If it is write-through, when the
        <code class="literal">map.put(key,value)</code>
        call returns,
        you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">MapStore.store(key,value)</code>
                    is successfully called so the
                    entry is persisted.
                </p></li><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li></ul></div><p>
        If it is write-behind, when the
        <code class="literal">map.put(key,value)</code>
        call returns, you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li><li class="listitem"><p>The entry is marked as
                    <code class="literal">dirty</code>
                    so that after
                    <code class="literal">write-delay-seconds</code>, it can be persisted.
                </p></li></ul></div><p>
        Same behavior goes for the
        <code class="literal">remove(key</code>
        and
        <code class="literal">MapStore.delete(key)</code>. If
        <code class="literal">MapStore</code>
        throws an
        exception then the exception will be propagated back to the original
        <code class="literal">put</code>
        or
        <code class="literal">remove</code>
        call in the form of
        <code class="literal">RuntimeException</code>. When write-through is used, Hazelcast will call
        <code class="literal">MapStore.store(key,value)</code>
        and
        <code class="literal">MapStore.delete(key)</code>
        for each entry update. When write-behind is
        used, Hazelcast will call<code class="literal">MapStore.store(map)</code>, and
        <code class="literal">MapStore.delete(collection)</code>
        to do all writes in a single call.
        Also note that your MapStore or MapLoader implementation should not use Hazelcast
        Map/Queue/MultiMap/List/Set operations. Your implementation should only work with your
        data store. Otherwise you may get into deadlock situations.
    </p><p>Here is a sample configuration:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Name of the class implementing MapLoader and/or MapStore.
               The class should implement at least of these interfaces and
               contain no-argument constructor. Note that the inner classes are not supported.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.examples.DummyStore<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Number of seconds to delay to call the MapStore.store(key, value).
               If the value is zero then it is write-through so MapStore.store(key, value)
               will be called as soon as the entry is updated.
               Otherwise it is write-behind so updates will be stored after write-delay-seconds
               value by calling Hazelcast.storeAll(map). Default value is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;write-delay-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/write-delay-seconds&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-store&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Initialization on
                startup:
            </strong></span>
        </span>
    </p><p>As of 1.9.3
        <code class="literal">MapLoader</code>
        has the new
        <code class="literal">MapLoader.loadAllKeys</code>
        API. It is used for pre-populating the
        in-memory map when the map is first touched/used. If
        <code class="literal">MapLoader.loadAllKeys</code>
        returns NULL then nothing will be loaded.
        Your
        <code class="literal">MapLoader.loadAllKeys</code>
        implementation can return all or some of the keys. You may
        select and return only the
        <code class="literal">hot</code>
        keys, for instance. Also note that
        this is the fastest way of pre-populating the map as Hazelcast will optimize the loading
        process by having each node loading owned portion of the entries.
    </p><p>Here is MapLoader initialization flow;
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When
                    <code class="code">getMap()</code>
                    first called from any node, initialization starts
                </p></li><li class="listitem"><p>Hazelcast will call
                    <code class="code">MapLoader.loadAllKeys()</code>
                    to get all your keys on each
                    node
                </p></li><li class="listitem"><p>Each node will figure out the list of keys it owns</p></li><li class="listitem"><p>Each node will load all its owned keys by calling
                    <code class="code">MapLoader.loadAll(keys)</code>
                </p></li><li class="listitem"><p>Each node puts its owned entries into the map by
                    calling
                    <code class="code">IMap.putTransient(key,value)</code>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.3.4.&nbsp;Query"><div class="titlepage"><div><div><h3 class="title"><a name="MapQuery"></a>2.3.4.&nbsp;Query</h3></div></div></div><p>Hazelcast partitions your data and spreads across cluster of servers. You can surely
        iterate over the map entries and look for certain entries you are interested in but this
        is not very efficient as you will have to bring entire entry set and iterate locally.
        Instead, Hazelcast allows you to run distributed queries on your distributed map.
    </p><p>Let's say you have a "employee" map containing values of
        <code class="literal">Employee</code>
        objects:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.io.Serializable;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Employee <strong class="hl-keyword">implements</strong> Serializable {
<strong class="hl-keyword">private</strong> String name;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> age;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">boolean</strong> active;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">double</strong> salary;

<strong class="hl-keyword">public</strong> Employee(String name, <strong class="hl-keyword">int</strong> age, <strong class="hl-keyword">boolean</strong> live, <strong class="hl-keyword">double</strong> price) {
    <strong class="hl-keyword">this</strong>.name = name;
    <strong class="hl-keyword">this</strong>.age = age;
    <strong class="hl-keyword">this</strong>.active = live;
    <strong class="hl-keyword">this</strong>.salary = price;
}

<strong class="hl-keyword">public</strong> Employee() {
}

<strong class="hl-keyword">public</strong> String getName() {
    <strong class="hl-keyword">return</strong> name;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getAge() {
    <strong class="hl-keyword">return</strong> age;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">double</strong> getSalary() {
    <strong class="hl-keyword">return</strong> salary;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> isActive() {
    <strong class="hl-keyword">return</strong> active;
}
}
</pre><p>Now you are looking for the employees who are active and with age less than 30.
        Hazelcast allows you to find these entries in two different ways:
    </p><p>
        <span class="bold"><strong>Distributed SQL Query</strong></span>
    </p><p>
        <code class="literal">SqlPredicate</code>
        takes regular SQL where clause. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.SqlPredicate;

IMap map = Hazelcast.getMap(<font font-style="normal" color="#008000">"employee"</font>);

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(<strong class="hl-keyword">new</strong> SqlPredicate(<font font-style="normal" color="#008000">"active AND age &lt; 30"</font>));
</pre><p>
        Supported SQL syntax:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>AND/OR
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; AND &lt;expression&gt; AND
                                    &lt;expression&gt;...
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">active AND age&gt;30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active=false OR age = 45 OR name =
                                                'Joe'
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active AND (age &gt;20 OR salary &lt;
                                                60000)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>
                    <code class="literal">=, !=, &lt;, &lt;=, &gt;, &gt;=</code>
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; = value</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age &lt;= 30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name ="Joe"</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">salary != 50000</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>BETWEEN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND
                                    &lt;value2&gt;</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age BETWEEN 20 AND 33 (same as age &gt;=20
                                                AND age&lt;=33)
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT BETWEEN 30 AND 40 (same as age
                                                &lt;30 OR age&gt;40)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>LIKE
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] LIKE 'expression'</code>
                            </p><p>
                                <code class="literal">%</code>
                                (percentage sign) is placeholder for many
                                characters,
                                <code class="literal">_</code>
                                (underscore) is placeholder for
                                only one character.
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo%'</code>
                                            (true for 'Joe',
                                            'Josh', 'Joseph' etc.)
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo_'</code>
                                            (true for 'Joe';
                                            false for 'Josh')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name NOT LIKE 'Jo_'</code>
                                            (true for
                                            'Josh'; false for 'Joe')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'J_s%'</code>
                                            (true for
                                            'Josh', 'Joseph'; false 'John', 'Joe')
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>IN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] IN (val1, val2,
                                    ...)
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age IN (20, 30, 40)</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT IN (60, 70)</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li></ul></div><p>
        Examples:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">active AND (salary &gt;= 50000 OR (age NOT BETWEEN 20 AND
                        30))
                    </code>
                </p></li><li class="listitem"><p>
                    <code class="literal">age IN (20, 30, 40) AND salary BETWEEN (50000, 80000)</code>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Criteria API</strong></span>
    </p><p>If SQL is not enough or programmable queries are preferred then JPA criteria like API
        can be used. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.Predicate;
<strong class="hl-keyword">import</strong> com.hazelcast.query.PredicateBuilder;
<strong class="hl-keyword">import</strong> com.hazelcast.query.EntryObject;

IMap map = Hazelcast.getMap(<font font-style="normal" color="#008000">"employee"</font>);

EntryObject e = <strong class="hl-keyword">new</strong> PredicateBuilder().getEntryObject();
Predicate predicate = e.is(<font font-style="normal" color="#008000">"active"</font>).and(e.get(<font font-style="normal" color="#008000">"age"</font>).lessThan(<span class="hl-number">30</span>));

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(predicate);

</pre><p>
    </p><p>
        <span class="bold"><strong>Indexing</strong></span>
    </p><p>Hazelcast distributed queries will run on each member in parallel and only results
        will return the caller. When a query runs on a member, Hazelcast will iterate through
        the entire owned entries and find the matching ones. Can we make this even faster? Yes
        by indexing the mostly queried fields. Just like you would do for your database. Of
        course, indexing will add overhead for each
        <code class="literal">write</code>
        operation but
        queries will be a lot faster. If you are querying your map a lot then make sure to add
        indexes for most frequently queried fields. So if your
        <code class="literal">active and age &lt;
            30
        </code>
        query, for example, is used a lot then make sure you add index for
        <code class="literal">active</code>
        and
        <code class="literal">age</code>
        fields. Here is how:
        </p><pre class="programlisting">IMap imap = Hazelcast.getMap(<font font-style="normal" color="#008000">"employees"</font>);
imap.addIndex(<font font-style="normal" color="#008000">"age"</font>, true);        <em class="hl-comment" style="color: silver">// ordered, since we have ranged queries for this field</em>
imap.addIndex(<font font-style="normal" color="#008000">"active"</font>, false);    <em class="hl-comment" style="color: silver">// not ordered, because boolean field cannot have range</em>
</pre><p>
        API
        <code class="literal">IMap.addIndex(fieldName, ordered)</code>
        is used for adding
        index. For a each indexed field, if you have -ranged- queries such
        as<code class="literal">age&gt;30</code>,
        <code class="literal">age BETWEEN 40 AND 60</code>
        then
        <code class="literal">ordered</code>
        parameter should be<code class="literal">true</code>, otherwise set
        it to<code class="literal">false</code>.
    </p></div><div class="sect2" title="2.3.5.&nbsp;Near Cache"><div class="titlepage"><div><div><h3 class="title"><a name="MapNearCache"></a>2.3.5.&nbsp;Near Cache</h3></div></div></div><p>Map entries in Hazelcast are partitioned across the cluster. Imagine that you are
        reading key
        <code class="literal">k</code>
        so many times and
        <code class="literal">k</code>
        is owned by another member in your cluster. Each
        <code class="literal">map.get(k)</code>
        will
        be a remote operation; lots of network trips.
        If you have a map that is read-mostly then you should consider creating a
        <code class="literal">Near Cache</code>
        for the map so that reads can be much faster and consume less network traffic.
        All these benefits don't come free. When using near cache, you should consider the following issues:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>JVM will have to hold extra cached data so it will increase the memory consumption.
                </p></li><li class="listitem"><p>If invalidation is turned on and entries are updated frequently, then invalidations will be
                    costly.
                </p></li><li class="listitem"><p>Near cache breaks the strong consistency guarantees; you might be reading stale data.
                </p></li></ul></div><p>
        Near cache is highly recommended for the maps that are read-mostly.
        Here is a near-cache configuration for a map :
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-read-mostly-map"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;near-cache&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum size of the near cache. When max size is reached,
                cache is evicted based on the policy defined.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds for each entry to stay in the near cache. Entries that are
                older than &lt;time-to-live-seconds&gt; will get automatically evicted from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds each entry can stay in the near cache as untouched (not-read).
                Entries that are not read (touched) more than &lt;max-idle-seconds&gt; value will get removed
                from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>60<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Valid values are:
                NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
                LRU  (Least Recently Used),
                LFU  (Least Frequently Used).
                NONE is the default.
                Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Should the cached entries get evicted if the entries are changed (updated or removed).
                true of false. Default is true.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;invalidate-on-change&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/invalidate-on-change&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;/near-cache&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p></div><div class="sect2" title="2.3.6.&nbsp;Entry Statistics"><div class="titlepage"><div><div><h3 class="title"><a name="MapEntry"></a>2.3.6.&nbsp;Entry Statistics</h3></div></div></div><p>
        Hazelcast keeps extra information about each map entry such as creationTime, lastUpdateTime, lastAccessTime,
        number of hits, version, and this information is exposed to the developer via
        <code class="literal">IMap.getMapEntry(key)</code>
        call. Here is
        an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.MapEntry;

MapEntry entry = Hazelcast.getMap(<font font-style="normal" color="#008000">"quotes"</font>).getMapEntry(<font font-style="normal" color="#008000">"1"</font>);
System.out.println (<font font-style="normal" color="#008000">"size in memory  : "</font> + entry.getCost();
System.out.println (<font font-style="normal" color="#008000">"creationTime    : "</font> + entry.getCreationTime();
System.out.println (<font font-style="normal" color="#008000">"expirationTime  : "</font> + entry.getExpirationTime();
System.out.println (<font font-style="normal" color="#008000">"number of hits  : "</font> + entry.getHits();
System.out.println (<font font-style="normal" color="#008000">"lastAccessedTime: "</font> + entry.getLastAccessTime();
System.out.println (<font font-style="normal" color="#008000">"lastUpdateTime  : "</font> + entry.getLastUpdateTime();
System.out.println (<font font-style="normal" color="#008000">"version         : "</font> + entry.getVersion();
System.out.println (<font font-style="normal" color="#008000">"isValid         : "</font> + entry.isValid();
System.out.println (<font font-style="normal" color="#008000">"key             : "</font> + entry.getKey();
System.out.println (<font font-style="normal" color="#008000">"value           : "</font> + entry.getValue();
System.out.println (<font font-style="normal" color="#008000">"oldValue        : "</font> + entry.setValue(newValue);
</pre><p>
    </p></div><div class="sect2" title="2.3.7.&nbsp;Indexing"><div class="titlepage"><div><div><h3 class="title"><a name="MapIndex"></a>2.3.7.&nbsp;Indexing</h3></div></div></div><p>
        Map entries can be indexed to be able to query faster. These indexes can be created using IMap API.
        But this usage has a limitation; all indexes must be created before any value is put into map.
        Sometimes by design adding an index to map may be impossible before any value is added.
        For example if a map has
        <code class="code">MapLoader</code>
        that loads entries during map creation,
        then adding indexes to map becomes meaningless.
        To solve this problem, Hazelcast introduces defining
        <code class="code">IMap</code>
        indexes in configuration.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>name<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>age<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Config API</span>
                    </p><pre class="programlisting">
                        mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"name"</font>, false));
                        mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"age"</font>, true));
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"name"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"age"</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font></pre><p>
                </p></li></ul></div><p>
    </p></div><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="12.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.4.&nbsp;Distributed MultiMap"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MultiMap"></a>2.4.&nbsp;Distributed MultiMap</h2></div></div></div><p>
        <code class="literal">MultiMap</code>
        is a specialized map where you can associate a key with multiple values.
        Just like any other distributed data structure implementation in Hazelcast,
        <code class="literal">MultiMap</code>
        is distributed/partitioned and thread-safe.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.MultiMap;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Collection;

<em class="hl-comment" style="color: silver">// a multimap to hold &lt;customerId, Order&gt; pairs</em>
MultiMap&lt;String, Order&gt; mmCustomerOrders = Hazelcast.getMultiMap(<font font-style="normal" color="#008000">"customerOrders"</font>);
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPhone"</font>, <span class="hl-number">340</span>));
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"MacBook"</font>, <span class="hl-number">1200</span>));
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPod"</font>, <span class="hl-number">79</span>));

<em class="hl-comment" style="color: silver">// get orders of the customer with customerId 1.</em>
Collection&lt;Order&gt; colOrders = mmCustomerOrders.get (<font font-style="normal" color="#008000">"1"</font>);
<strong class="hl-keyword">for</strong> (Order order : colOrders) {
    <em class="hl-comment" style="color: silver">// process order</em>
}

<em class="hl-comment" style="color: silver">// remove specific key/value pair</em>
<strong class="hl-keyword">boolean</strong> removed = mmCustomerOrders.remove(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPhone"</font>, <span class="hl-number">340</span>));
</pre><p>

    </p></div><div class="sect1" title="2.5.&nbsp;Distributed Set"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Set"></a>2.5.&nbsp;Distributed Set</h2></div></div></div><p>Distributed Set is distributed and concurrent implementation
        of<code class="literal">java.util.Set</code>. Set doesn't allow duplicate elements, so elements in
        the set should have proper hashCode and equals methods.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Set;
<strong class="hl-keyword">import</strong> java.util.Iterator;

java.util.Set set = Hazelcast.getSet(<font font-style="normal" color="#008000">"IBM-Quote-History"</font>);
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">10</span>, time1));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>, time2));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>, time3));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>, time4));
<em class="hl-comment" style="color: silver">//....</em>
Iterator it = set.iterator();
<strong class="hl-keyword">while</strong> (it.hasNext()) { 
    Price price = (Price) it.next(); 
    <em class="hl-comment" style="color: silver">//analyze</em>
}

</pre><p>
    </p></div><div class="sect1" title="2.6.&nbsp;Distributed List"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="List"></a>2.6.&nbsp;Distributed List</h2></div></div></div><p>Distributed List is very similar to distributed set, but it allows duplicate elements.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.List;
<strong class="hl-keyword">import</strong> java.util.Iterator;

java.util.List list = Hazelcast.getList(<font font-style="normal" color="#008000">"IBM-Quote-Frequency"</font>);
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">10</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>));
        
<em class="hl-comment" style="color: silver">//....</em>
Iterator it = list.iterator();
<strong class="hl-keyword">while</strong> (it.hasNext()) { 
    Price price = (Price) it.next(); 
    <em class="hl-comment" style="color: silver">//analyze</em>
}
</pre><p>
    </p></div><div class="sect1" title="2.7.&nbsp;Distributed Lock"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Lock"></a>2.7.&nbsp;Distributed Lock</h2></div></div></div><p>
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.locks.Lock;

Lock lock = Hazelcast.getLock(myLockedObject);
lock.lock();
<strong class="hl-keyword">try</strong> {
    <em class="hl-comment" style="color: silver">// do something here</em>
} <strong class="hl-keyword">finally</strong> {
    lock.unlock();
} 
 
</pre><p>

        <code class="literal">java.util.concurrent.locks.Lock.tryLock()</code>
        with timeout is also supported. All operations on the Lock that
        <code class="literal">Hazelcast.getLock(Object obj)</code>
        returns are cluster-wide and Lock behaves just like
        <code class="literal">java.util.concurrent.lock.ReentrantLock</code>.

        </p><pre class="programlisting"><strong class="hl-keyword">if</strong> (lock.tryLock (<span class="hl-number">5000</span>, TimeUnit.MILLISECONDS)) {
    <strong class="hl-keyword">try</strong> {  
       <em class="hl-comment" style="color: silver">// do some stuff here..  </em>
    } 
    <strong class="hl-keyword">finally</strong> {  
      lock.unlock();  
    }   
} 
</pre><p>

        Locks are fail-safe. If a member holds a lock and some of the members go down, cluster will keep your locks safe
        and available. Moreover, when a member leaves the cluster, all the locks acquired by this dead member will be
        removed so that these locks can be available for live members immediately.

    </p></div><div class="sect1" title="2.8.&nbsp;Distributed Events"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Events"></a>2.8.&nbsp;Distributed Events</h2></div></div></div><p>
        Hazelcast allows you to register for entry events to get notified when entries added, updated or removed.
        Listeners are cluster-wide. When a member adds a listener, it is actually registering for events originated in
        any member in the cluster. When a new member joins, events originated at the new member will also be delivered.

        All events are ordered, meaning, listeners will receive and process the events in the order they are actually
        occurred.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Queue;
<strong class="hl-keyword">import</strong> java.util.Map; 
<strong class="hl-keyword">import</strong> java.util.Set; 
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.ItemListener;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryListener;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryEvent; 

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> ItemListener, EntryListener {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) { 
        Sample sample = <strong class="hl-keyword">new</strong> Sample();
        Queue queue = Hazelcast.getQueue (<font font-style="normal" color="#008000">"default"</font>); 
        Map   map   = Hazelcast.getMap   (<font font-style="normal" color="#008000">"default"</font>); 
        Set   set   = Hazelcast.getSet   (<font font-style="normal" color="#008000">"default"</font>); 
        <em class="hl-comment" style="color: silver">//listen for all added/updated/removed entries</em>
        queue.addItemListener(sample, true);
        set.addItemListener  (sample, true); 
        map.addEntryListener (sample, true);        
        <em class="hl-comment" style="color: silver">//listen for an entry with specific key </em>
        map.addEntryListener (sample, <font font-style="normal" color="#008000">"keyobj"</font>);        
    } 

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryAdded(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry added key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryRemoved(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry removed key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryUpdated(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry update key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    } 

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryEvicted(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry evicted key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    } 
    
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> itemAdded(Object item) {
        System.out.println(<font font-style="normal" color="#008000">"Item added = "</font> + item);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> itemRemoved(Object item) {
        System.out.println(<font font-style="normal" color="#008000">"Item removed = "</font> + item);
    }     
}
       
</pre><p>

    </p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Elastic Memory (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title"><a name="ElasticMemory"></a>Chapter&nbsp;3.&nbsp;Elastic Memory
            <sup>(Enterprise Edition Only)</sup>
        </h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        By default, Hazelcast stores your distributed data (map entries, queue items) into Java heap
        which is subject to garbage collection. As your heap gets bigger, garbage collection might
        cause your application to pause tens of seconds, badly effecting your application performance
        and response times. Elastic Memory is Hazelcast with off-heap (direct) memory storage to avoid GC pauses.
        Even if you have terabytes of cache in-memory with lots of updates, GC will have almost no effect;
        resulting in more predictable latency and throughput.
    </p><p>
        Here are the steps to enable Elastic Memory:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    Set the maximum direct memory JVM can allocate.
                    Example
                    <code class="literal">java -XX:MaxDirectMemorySize=60G ...</code>
                </p></li><li class="listitem"><p>
                    Enable Elastic Memory by setting
                    <code class="literal">hazelcast.elastic.memory.enabled</code>
                    <a class="link" href="#ConfigurationProperties" title="12.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>
                    to
                    <code class="literal">true</code>.
                </p></li><li class="listitem"><p>
                    Set the total direct memory size for HazelcastInstance by setting
                    <code class="literal">hazelcast.elastic.memory.total.size</code>
                    <a class="link" href="#ConfigurationProperties" title="12.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>. Size can be
                    in MB or GB and abbreviation can be used, such as
                    <code class="literal">60G</code>
                    and
                    <code class="literal">500M</code>.
                </p></li><li class="listitem"><p>
                    Set the chunk size in KB by setting
                    <code class="literal">hazelcast.elastic.memory.chunk.size</code>
                    <a class="link" href="#ConfigurationProperties" title="12.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>.
                    Hazelcast will partition the entire offheap memory into chunks.
                    Default chunk size is 1. Chunk size has to be power of 2 such as 1, 2, 4 and 8.
                </p></li><li class="listitem"><p>
                    Configure maps you want them to use Elastic Memory by setting
                    <code class="literal">StorageType</code>
                    to<code class="code">OFFHEAP</code>.
                    Default value is<code class="code">HEAP</code>.
                </p><p>
                    Using XML configuration:
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;storage-type&gt;</font>OFFHEAP<font font-style="bold" color="#0A1777">&lt;/storage-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p><p>
                    Using Config API:
                    </p><pre class="programlisting">MapConfig mapConfig = <strong class="hl-keyword">new</strong> MapConfig();
mapConfig.setStorageType(StorageType.OFFHEAP);</pre><p>
                </p></li></ul></div><p>
    </p><p>
        If
        <code class="literal">NearCache</code>
        is defined for a map, all near cached items are also going to be
        stored on the same off-heap. So off-heap storage is used for both near cache and distributed object
        storage.
    </p><p>
        <span class="italic">Also see how to <a class="link" href="#EnterpriseConfig" title="12.8.&nbsp;Setting License Key (Enterprise Edition Only)">configure license key</a>.</span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Security (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title"><a name="Security"></a>Chapter&nbsp;4.&nbsp;Security
            <sup>(Enterprise Edition Only)</sup>
        </h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Credentials">4.1. Credentials</a></span></dt><dt><span class="sect1"><a href="#ClusterLoginModule">4.2. ClusterLoginModule</a></span></dt><dt><span class="sect1"><a href="#MemberSecurity">4.3. Cluster Member Security</a></span></dt><dt><span class="sect1"><a href="#ClientSecurity">4.4. Native Client Security</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1373">4.4.1. Authentication</a></span></dt><dt><span class="sect2"><a href="#d0e1409">4.4.2. Authorization</a></span></dt><dt><span class="sect2"><a href="#d0e1468">4.4.3. Permissions</a></span></dt></dl></dd></dl></div><p>
    Hazelcast has an extensible, JAAS based security feature
    which can be used to authenticate both cluster members and clients and to do access control checks
    on client operations. Access control can be done according to endpoint principal and/or endpoint address.
    Security can be enabled and configured either in configuration xml or using Config api.
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-2.3.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    
    ...
    <font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
SecurityConfig securityCfg = cfg.getSecurityConfig();
securityCfg.setEnabled(true);
</pre><p>

    <span class="italic">Also see how to <a class="link" href="#EnterpriseConfig" title="12.8.&nbsp;Setting License Key (Enterprise Edition Only)">configure license key</a>.</span>
</p><div class="sect1" title="4.1.&nbsp;Credentials"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Credentials"></a>4.1.&nbsp;Credentials</h2></div></div></div><p>One of the key elements in Hazelcast security is
        <code class="literal">Credentials</code>
        object. It
        is used to carry all credentials of an endpoint (member or client).
        <code class="literal">Credentials</code>
        is an interface which extends
        <code class="code">Serializable</code>
        and has three methods to be implemented. Users,
        according to their needs, can either implement
        <code class="literal">Credentials</code>
        interface or
        extend
        <code class="literal">AbstractCredentials</code>
        class which is an abstract implementation of
        <code class="literal">Credentials</code>.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> Credentials <strong class="hl-keyword">extends</strong> Serializable {

    String getEndpoint();

    <strong class="hl-keyword">void</strong> setEndpoint(String endpoint) ;
    
    String getPrincipal() ;    
}
</pre><p>
        <code class="code">Credentials.setEndpoint()</code>
        method is called by Hazelcast when auth request arrives to node
        before authentication takes place.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">class</strong> AbstractCredentials <strong class="hl-keyword">implements</strong> Credentials, DataSerializable {
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> String endpoint;
    <strong class="hl-keyword">private</strong> String principal;

    ...
}
</pre><p>
        <code class="literal">UsernamePasswordCredentials</code>, a custom implementation of
        <code class="literal">Credentials</code>
        can be found in Hazelcast
        <code class="code">com.hazelcast.security</code>
        package. It is used by default configuration during
        authentication process of both members and clients.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> UsernamePasswordCredentials <strong class="hl-keyword">extends</strong> Credentials {
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">byte</strong>[] password;
    ...
}
</pre><p>
    </p></div><div class="sect1" title="4.2.&nbsp;ClusterLoginModule"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterLoginModule"></a>4.2.&nbsp;ClusterLoginModule</h2></div></div></div><p>All security attributes are carried in
        <code class="literal">Credentials</code>
        object and
        <code class="literal">Credentials</code>
        is used by
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/spi/LoginModule.html" target="_top">
            <code class="literal">LoginModule</code>
        </a>
        s during authentication process. Accessing
        user supplied attributes from
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/spi/LoginModule.html" target="_top">
            <code class="literal">LoginModule</code>
        </a>
        s is done by
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/callback/CallbackHandler.html" target="_top">
            <code class="literal">CallbackHandler</code>
        </a>
        s. To provide access to
        <code class="literal">Credentials</code>
        object, Hazelcast uses its own specialized
        <code class="literal">CallbackHandler</code>. During initialization of
        <code class="literal">LoginModule</code>s Hazelcast will pass this special
        <code class="literal">CallbackHandler</code>into
        <code class="code">LoginModule.initialize()</code>
        method.
    </p><p>
        <code class="literal">LoginModule</code>
        implementations should create an instance of
        <code class="literal">com.hazelcast.security.CredentialsCallback</code>
        and call
        <code class="code">handle(Callback[] callbacks)</code>
        method of
        <code class="literal">CallbackHandler</code>
        during login process.
        <code class="code">CredentialsCallback.getCredentials()</code>
        will return supplied
        <code class="literal">Credentials</code>
        object.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> CustomLoginModule <strong class="hl-keyword">implements</strong> LoginModule {
    CallbackHandler callbackHandler;
    Subject subject;

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">void</strong> initialize(Subject subject, CallbackHandler callbackHandler,
        Map&lt;String, ?&gt; sharedState, Map&lt;String, ?&gt; options) {
        <strong class="hl-keyword">this</strong>.subject = subject;
        <strong class="hl-keyword">this</strong>.callbackHandler = callbackHandler;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">boolean</strong> login() <strong class="hl-keyword">throws</strong> LoginException {
        CredentialsCallback callback = <strong class="hl-keyword">new</strong> CredentialsCallback();
        <strong class="hl-keyword">try</strong> {
            callbackHandler.handle(<strong class="hl-keyword">new</strong> Callback[]{callback});
            credentials = cb.getCredentials();
        } <strong class="hl-keyword">catch</strong> (Exception e) {
            <strong class="hl-keyword">throw</strong> <strong class="hl-keyword">new</strong> LoginException(e.getMessage());
        }
        ...
    }
...
}
</pre><p>
    </p><p>* To use default Hazelcast permission policy, an instance of
        <code class="code">com.hazelcast.security.ClusterPrincipal</code>
        that holding
        <code class="literal">Credentials</code>
        object must be created and added to
        <code class="code">Subject.principals</code>
        on<code class="code">LoginModule.commit()</code>.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyCustomLoginModule <strong class="hl-keyword">implements</strong> LoginModule {
...
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> commit() <strong class="hl-keyword">throws</strong> LoginException {
        ...
        <strong class="hl-keyword">final</strong> Principal principal = <strong class="hl-keyword">new</strong> ClusterPrincipal(credentials);
        subject.getPrincipals().add(principal);
        
        <strong class="hl-keyword">return</strong> true;
    }
    ...
}
</pre><p>
    </p><p>Hazelcast also has an abstract implementation of
        <code class="literal">LoginModule</code>
        that does
        callback and cleanup operations and holds resulting
        <code class="literal">Credentials</code>
        instance.
        <code class="literal">LoginModule</code>s extending
        <code class="literal">ClusterLoginModule</code>
        can access<code class="literal">Credentials</code>,
        <code class="literal">Subject</code>,
        <code class="literal">LoginModule</code>
        instances and
        <code class="code">options</code>
        and
        <code class="code">sharedState</code>
        maps. Extending
        <code class="literal">ClusterLoginModule</code>
        is recommended instead of implementing all required stuff.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">class</strong> ClusterLoginModule <strong class="hl-keyword">implements</strong> LoginModule {

    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onLogin() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onCommit() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onAbort() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onLogout() <strong class="hl-keyword">throws</strong> LoginException;

}
</pre><p>
    </p></div><div class="sect1" title="4.3.&nbsp;Cluster Member Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MemberSecurity"></a>4.3.&nbsp;Cluster Member Security</h2></div></div></div><p>Hazelcast supports standard Java Security (JAAS) based authentication between cluster
        members. You should configure one or more<code class="code">LoginModule</code>s and an instance of
        <code class="literal">com.hazelcast.security.ICredentialsFactory</code>. Although Hazelcast has
        default implementations using cluster group and group-password and
        <code class="literal">UsernamePasswordCredentials</code>
        on authentication, it is advised to
        implement these according to specific needs and environment.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-credentials-factory</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyCredentialsFactory"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property1"</font><font font-style="bold" color="#0A1777">&gt;</font>value1<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property2"</font><font font-style="bold" color="#0A1777">&gt;</font>value2<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-credentials-factory&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-login-modules&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyRequiredLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"required"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property3"</font><font font-style="bold" color="#0A1777">&gt;</font>value3<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MySufficientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"sufficient"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property4"</font><font font-style="bold" color="#0A1777">&gt;</font>value4<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyOptionalLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"optional"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property5"</font><font font-style="bold" color="#0A1777">&gt;</font>value5<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-login-modules&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        You can define as many as<code class="literal">LoginModule</code>s you wanted in
        configuration. Those are executed in given order. Usage attribute has 4 values; 'required',
        'requisite', 'sufficient' and 'optional' as defined in
        <code class="code">javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.
    </p><p>
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
<strong class="hl-tag" style="color: blue">/**
 * ICredentialsFactory is used to create Credentials objects to be used
 * during node authentication before connection accepted by master node.
 */</strong>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> ICredentialsFactory {

    <strong class="hl-keyword">void</strong> configure(GroupConfig groupConfig, Properties properties);

    Credentials newCredentials();

    <strong class="hl-keyword">void</strong> destroy();
}
</pre><p>
    </p><p>
        Properties defined in configuration are passed to
        <code class="code">ICredentialsFactory.configure()</code>
        method as
        <code class="code">java.util.Properties</code>
        and to
        <code class="code">LoginModule.initialize()</code>
        method as<code class="code">java.util.Map</code>.
    </p></div><div class="sect1" title="4.4.&nbsp;Native Client Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClientSecurity"></a>4.4.&nbsp;Native Client Security</h2></div></div></div><p>Hazelcast's Client security includes both authentication and authorization.</p><div class="sect2" title="4.4.1.&nbsp;Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1373"></a>4.4.1.&nbsp;Authentication</h3></div></div></div><p>Authentication mechanism just works the same as cluster member authentication. Implementation of client
            authentication requires a
            <code class="literal">Credentials</code>
            and one or more
            <code class="literal">LoginModule</code>(s). Client side does not have/need a factory object to
            create
            <code class="literal">Credentials</code>
            objects like<code class="literal">ICredentialsFactory</code>.
            <code class="literal">Credentials</code>
            must be created at client side and sent to connected node
            during connection process.
            </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;client-login-modules&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyRequiredClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"required"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property3"</font><font font-style="bold" color="#0A1777">&gt;</font>value3<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MySufficientClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"sufficient"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property4"</font><font font-style="bold" color="#0A1777">&gt;</font>value4<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyOptionalClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"optional"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property5"</font><font font-style="bold" color="#0A1777">&gt;</font>value5<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/client-login-modules&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        </p><p>You can define as many as<code class="literal">LoginModule</code>s you wanted in
            configuration. Those are executed in given order. Usage attribute has 4 values; 'required',
            'requisite', 'sufficient' and 'optional' as defined in
            <code class="code">javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.
        </p><p>
            </p><pre class="programlisting">
<strong class="hl-keyword">final</strong> Credentials credentials = <strong class="hl-keyword">new</strong> UsernamePasswordCredentials(<font font-style="normal" color="#008000">"dev"</font>, <font font-style="normal" color="#008000">"dev-pass"</font>);
HazelcastInstance client = HazelcastClient.newHazelcastClient(credentials, <font font-style="normal" color="#008000">"localhost"</font>);
</pre><p>
        </p></div><div class="sect2" title="4.4.2.&nbsp;Authorization"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1409"></a>4.4.2.&nbsp;Authorization</h3></div></div></div><p>Hazelcast client authorization is configured by a client permission policy. Hazelcast has a default
            permission policy
            implementation that uses permission configurations defined in Hazelcast security configuration. Default
            policy permission checks are done
            against instance types (map, queue...), instance names (map, queue etc. name), instance actions (put, get,
            remove, add...),
            client endpoint addresses and client principal defined by
            <code class="literal">Credentials</code>
            object.
            <span class="italic">Instance and principal names and endpoint addresses
                can be defined as wildcards(*). Take a look at
                <a class="link" href="#WildcardConfiguration" title="12.5.&nbsp;Wildcard Configuration">Wildcard Name Configuration</a>
                and
                <a class="link" href="#ConfigSpecifyInterfaces" title="12.2.2.&nbsp;Specifying Network Interfaces">Newtwork Configuration</a>
                pages.
            </span>
        </p><p>
            </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;client-permissions&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!-- Principal 'admin' from endpoint '127.0.0.1' has all permissions. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;all-permissions</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"admin"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>127.0.0.1<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/all-permissions&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- Principals named 'dev' from all endpoints have 'create', 'destroy', 
            'put', 'get' permissions for map named 'default'. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>create<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>destroy<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>put<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>get<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- All principals from endpoints '127.0.0.1' or matching to '10.10.*.*' 
            have 'put', 'get', 'remove' permissions for map 
            whose name matches to 'com.foo.entity.*'. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.foo.entity.*"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>10.10.*.*<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>127.0.0.1<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>put<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>get<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>remove<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- Principals named 'dev' from endpoints matching to either 
            '192.168.1.1-100' or '192.168.2.*' 
            have 'create', 'offer', 'poll' permissions for all queues. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;queue-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>192.168.1.1-100<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>192.168.2.*<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>create<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>offer<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>poll<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/queue-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- All principals from all endpoints have transaction permission.--&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;transaction-permission /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/client-permissions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        </p><p>Users also can define their own policy by implementing<code class="literal">
            com.hazelcast.security.IPermissionPolicy</code>.
            </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
<strong class="hl-tag" style="color: blue">/**
 * IPermissionPolicy is used to determine any Subject's 
 * permissions to perform a security sensitive Hazelcast operation.
 *
 */</strong>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> IPermissionPolicy {
    <strong class="hl-keyword">void</strong> configure(SecurityConfig securityConfig, Properties properties);
    
    PermissionCollection getPermissions(Subject subject, Class&lt;? <strong class="hl-keyword">extends</strong> Permission&gt; type);
    
    <strong class="hl-keyword">void</strong> destroy();
}</pre><p>
        </p><p>Permission policy implementations can access
            <code class="code">client-permissions</code>
            in
            configuration by using
            <code class="code">SecurityConfig.getClientPermissionConfigs()</code>
            during
            <code class="code">configure(SecurityConfig securityConfig, Properties properties)</code>
            method
            is called by Hazelcast.
            <code class="code">IPermissionPolicy.getPermissions(Subject subject,
                Class&lt;? extends Permission&gt; type)
            </code>
            method is used to determine a client
            request has been granted permission to do a security-sensitive operation. Permission
            policy should return a
            <code class="literal">PermissionCollection</code>
            containing permissions of
            given type for given<code class="literal">Subject</code>. Hazelcast access controller will call
            <code class="code">PermissionCollection.implies(Permission)</code>
            on returning
            <code class="literal">PermissionCollection</code>
            and will decide if current
            <code class="literal">Subject</code>
            has permitted to access to requested resources or
            not.
        </p></div><div class="sect2" title="4.4.3.&nbsp;Permissions"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1468"></a>4.4.3.&nbsp;Permissions</h3></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        <span class="bold"><strong>All Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;all-permissions</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/all-permissions&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Map Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            put, get, remove, listen, lock, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Queue Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;queue-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/queue-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            offer, poll, get, remove, listen, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Multimap Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;multimap-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/multimap-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            put, get, remove, listen, lock, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Topic Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;topic-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/topic-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">create, destroy,
                            publish, listen, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>List Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;list-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/list-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            add, set, get, remove, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Set Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;set-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/set-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            add, get, remove, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Lock Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;lock-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/lock-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            lock, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>AtomicNumber Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;atomic-number-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/atomic-number-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            increment, decrement, get, set, add, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>CountDownLatch Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;countdown-latch-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/countdown-latch-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            countdown, set, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Semaphore Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;semaphore-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/semaphore-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            acquire, release, drain, stats
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Executor Service Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;executor-service-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/executor-service-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            execute
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Listener Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listener-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listener-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Names:</strong></span>
                        <span class="italic">all, instance,
                            member
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Transaction Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;transaction-permission</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/transaction-permission&gt;</font>
</pre><p>
                    </p></li></ol></div><p>
        </p></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Data Affinity"><div class="titlepage"><div><div><h2 class="title"><a name="DataAffinity"></a>Chapter&nbsp;5.&nbsp;Data Affinity</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        <span class="emphasis"><em>Co-location of related data and computation!</em></span>
    </p><p>Hazelcast has a standard way of finding out which member owns/manages each key object.
        Following operations will be routed to the same member, since all of them are
        operating based on the same key, "key1".
    </p><pre class="programlisting">
        
Hazelcast.getMap(<font font-style="normal" color="#008000">"mapa"</font>).put(<font font-style="normal" color="#008000">"key1"</font>, value);
Hazelcast.getMap(<font font-style="normal" color="#008000">"mapb"</font>).get(<font font-style="normal" color="#008000">"key1"</font>);
Hazelcast.getMap(<font font-style="normal" color="#008000">"mapc"</font>).remove(<font font-style="normal" color="#008000">"key1"</font>);
<em class="hl-comment" style="color: silver">// since map names are different, operation will be manipulating</em>
<em class="hl-comment" style="color: silver">// different entries, but the operation will take place on the</em>
<em class="hl-comment" style="color: silver">// same member since the keys ("key1") are the same</em>

Hazelcast.getLock (<font font-style="normal" color="#008000">"key1"</font>).lock();
<em class="hl-comment" style="color: silver">// lock operation will still execute on the same member of the cluster</em>
<em class="hl-comment" style="color: silver">// since the key ("key1") is same</em>

Hazelcast.getExecutorService().execute(<strong class="hl-keyword">new</strong> DistributedTask(runnable, <font font-style="normal" color="#008000">"key1"</font>));
<em class="hl-comment" style="color: silver">// distributed execution will execute the 'runnable' on the same member</em>
<em class="hl-comment" style="color: silver">// since "key1" is passed as the key.</em>
    </pre><p>So when the keys are the same then entries are stored on the same node. But we
        sometimes want to have related entries stored on the same node. Consider customer
        and his/her order entries. We would have customers map with customerId as the key
        and orders map with orderId as the key. Since customerId and orderIds are different
        keys, customer and his/her orders may fall into different members/nodes in your cluster.
        So how can we have them stored on the same node? The trick here is to create an affinity
        between customer and orders. If we can somehow make them part of the same partition then
        these entries will be co-located. We achieve this by making orderIds
        <code class="literal">PartitionAware</code>
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> OrderKey <strong class="hl-keyword">implements</strong> Serializable, PartitionAware {
    <strong class="hl-keyword">int</strong> customerId;
    <strong class="hl-keyword">int</strong> orderId;

    <strong class="hl-keyword">public</strong> OrderKey(<strong class="hl-keyword">int</strong> orderId, <strong class="hl-keyword">int</strong> customerId) {
        <strong class="hl-keyword">this</strong>.customerId = customerId;
        <strong class="hl-keyword">this</strong>.orderId = orderId;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getCustomerId() {
        <strong class="hl-keyword">return</strong> customerId;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getOrderId() {
        <strong class="hl-keyword">return</strong> orderId;
    }

    <strong class="hl-keyword">public</strong> Object getPartitionKey() {
        <strong class="hl-keyword">return</strong> customerId;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> String toString() {
        <strong class="hl-keyword">return</strong> <font font-style="normal" color="#008000">"OrderKey{"</font> +
                <font font-style="normal" color="#008000">"customerId="</font> + customerId +
                <font font-style="normal" color="#008000">", orderId="</font> + orderId +
                <font font-style="normal" color="#008000">'}'</font>;
    }
}
        </pre><p>
    Notice that OrderKey implements <code class="literal">PartitionAware</code> and
    <code class="literal">getPartitionKey()</code> returns the
    <code class="literal">customerId</code>. This will make sure that <code class="literal">Customer</code>
    entry and its <code class="literal">Order</code>s are going to be stored on the same node.
    </p><pre class="programlisting">
Map mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>)
Map mapOrders = Hazelcast.getMap(<font font-style="normal" color="#008000">"orders"</font>)
<em class="hl-comment" style="color: silver">// create the customer entry with customer id = 1</em>
mapCustomers.put(<span class="hl-number">1</span>, customer);
<em class="hl-comment" style="color: silver">// now create the orders for this customer</em>
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">21</span>, <span class="hl-number">1</span>), order);
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">22</span>, <span class="hl-number">1</span>), order);
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">23</span>, <span class="hl-number">1</span>), order);
    </pre><p>
        Let say you have a customers map where
        <code class="literal">customerId</code>
        is the key and the customer
        object is the value. and customer object contains the customer's orders. and let say
        you want to remove one of the orders of a customer and return the number of
        remaining orders. Here is how you would normally do it:
    </p><pre class="programlisting">
        
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">int</strong> removeOrder(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) <strong class="hl-keyword">throws</strong> Exception {
    IMap&lt;Long, Customer&gt; mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    mapCustomers.lock (customerId);
    Customer customer = mapCustomers. get(customerId);
    customer.removeOrder (orderId);
    mapCustomers.put(customerId, customer);
    mapCustomers.unlock(customerId);
    <strong class="hl-keyword">return</strong> customer.getOrderCount();
}
</pre><p>
    There are couple of things we should consider:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>There are four distributed operations there.. lock, get, put,
                unlock.. Can we reduce the number of distributed operations?
            </p></li><li class="listitem"><p>Customer object may not be that big but can we not have to
                pass that object through the wire? Notice that, we are
                actually passing customer object through the wire twice; get
                and put.
            </p></li></ol></div><p>
    </p><p>So instead, why not moving the computation over to the member
        (JVM) where your customer data actually is.
        Here is how you can do this with distributed executor service:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Send a
                <code class="literal">PartitionAware</code>
                <code class="literal">Callable</code>
                task.
            </p></li><li class="listitem"><p>
                <code class="literal">Callable</code>
                does the deletion of the order right there and returns with
                the remaining order count.
            </p></li><li class="listitem"><p>
            Upon completion of the
            <code class="literal">Callable</code>
            task, return the
            result (remaining order count). Plus you do not
            have to wait until the the task complete; since
            distributed executions are asynchronous, you can
            do other things in the meantime.
            </p></li></ol></div><p>
    Here is a sample code:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">int</strong> removeOrder(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) <strong class="hl-keyword">throws</strong> Exception {
    ExecutorService es = Hazelcast.getExecutorService();
    OrderDeletionTask task = <strong class="hl-keyword">new</strong> OrderDeletionTask(customerId, orderId);
    Future future = es.submit(task);
    <strong class="hl-keyword">int</strong> remainingOrders = future.get();
    <strong class="hl-keyword">return</strong> remainingOrders;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> OrderDeletionTask <strong class="hl-keyword">implements</strong> Callable&lt;Integer&gt;, PartitionAware, Serializable {

   <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> customerId;
   <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> orderId;

   <strong class="hl-keyword">public</strong> OrderDeletionTask() {
   }
   <strong class="hl-keyword">public</strong> OrderDeletionTask(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) {
       <strong class="hl-keyword">super</strong>();
       <strong class="hl-keyword">this</strong>.customerId = customerId;
       <strong class="hl-keyword">this</strong>.orderId = orderId;
   }
   <strong class="hl-keyword">public</strong> Integer call () {
       IMap&lt;Long, Customer&gt; mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);
       mapCustomers.lock (customerId);
       Customer customer = mapCustomers. get(customerId);
       customer.removeOrder (orderId);
       mapCustomers.put(customerId, customer);
       mapCustomers.unlock(customerId);
       <strong class="hl-keyword">return</strong> customer.getOrderCount();
   }

   <strong class="hl-keyword">public</strong> Object getPartitionKey() {
       <strong class="hl-keyword">return</strong> customerId;
   }
}
        </pre><p>
    </p><p>
    Benefits of doing the same operation with
    distributed
    <code class="literal">ExecutorService</code>
    based on the key are:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                Only one distributed execution (<code class="literal">es.submit(task)</code>), instead of four.
            </p></li><li class="listitem"><p>
                Less data is sent over the wire.
            </p></li><li class="listitem"><p>
                Since lock/update/unlock cycle is done locally (local to the customer data), lock duration for the
                <code class="literal">Customer</code>
                entry is much less so enabling higher concurrency.
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Monitoring with JMX"><div class="titlepage"><div><div><h2 class="title"><a name="JMX"></a>Chapter&nbsp;6.&nbsp;Monitoring with JMX</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add the following system properties to enable
                <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/guide/management/agent.html" target="_top">jmx agent
                </a>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>-Dcom.sun.management.jmxremote</p></li><li class="listitem"><p>-Dcom.sun.management.jmxremote.port=_portNo_ (to specify jmx port)
                        <span class="emphasis"><em>optional</em></span>
                    </p></li><li class="listitem"><p>-Dcom.sun.management.jmxremote.authenticate=false (to disable jmx auth)
                        <span class="emphasis"><em>optional</em></span>
                    </p></li></ul></div></li><li class="listitem"><p>Enable Hazelcast property
                <span class="emphasis"><em>hazelcast.jmx</em></span>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>using Hazelcast configuration (api, xml, spring)</p></li><li class="listitem"><p>or set system property -Dhazelcast.jmx=true</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Use jconsole, jvisualvm (with mbean plugin) or another jmx-compliant monitoring
                tool.
            </p></li></ul></div><p>
    <span class="bold"><strong>Following attributes can be monitored:</strong></span>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Cluster
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>config</p></li><li class="listitem"><p>group name</p></li><li class="listitem"><p>count of members and their addresses (host:port)</p></li><li class="listitem"><p>operations: restart, shutdown cluster</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Member
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>inet address</p></li><li class="listitem"><p>port</p></li><li class="listitem"><p>lite member state</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Statistics
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>count of instances</p></li><li class="listitem"><p>number of instances created, destroyed since startup</p></li><li class="listitem"><p>max instances created, destroyed per second</p></li></ul></div><p>
            </p></li><li class="listitem"><p>AtomicNumber
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>actual value</p></li><li class="listitem"><p>operations: add, set, compareAndSet, reset</p></li></ul></div><p>
            </p></li><li class="listitem"><p>List, Set
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>items (as strings)</p></li><li class="listitem"><p>operations: clear, reset statistics</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Map
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>operations: clear</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Queue
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>received and served items</p></li><li class="listitem"><p>operations: clear, reset statistics</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Topic
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>number of messages dispatched since creation, in last second</p></li><li class="listitem"><p>max messages dispatched per second</p></li></ul></div><p>
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Cluster Utilities"><div class="titlepage"><div><div><h2 class="title"><a name="ClusterUtilities"></a>Chapter&nbsp;7.&nbsp;Cluster Utilities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ClusterInterface">7.1. Cluster Interface</a></span></dt><dt><span class="sect1"><a href="#IdGenerator">7.2. Cluster-wide Id Generator</a></span></dt><dt><span class="sect1"><a href="#LiteMember">7.3. LiteMember</a></span></dt></dl></div><div class="sect1" title="7.1.&nbsp;Cluster Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterInterface"></a>7.1.&nbsp;Cluster Interface</h2></div></div></div><p>
        Hazelcast allows you to register for membership events to get notified when members added or removed. You can
        also get the set of cluster members.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.*;

Cluster cluster = Hazelcast.getCluster();
cluster.addMembershipListener(<strong class="hl-keyword">new</strong> MembershipListener(){
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> memberAdded(MembershipEvent membersipEvent) {
        System.out.println(<font font-style="normal" color="#008000">"MemberAdded "</font> + membersipEvent);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> memberRemoved(MembershipEvent membersipEvent) {
        System.out.println(<font font-style="normal" color="#008000">"MemberRemoved "</font> + membersipEvent);
    }
});

Member localMember  = cluster.getLocalMember();
System.out.println (<font font-style="normal" color="#008000">"my inetAddress= "</font> + localMember.getInetAddress());

Set setMembers  = cluster.getMembers();
<strong class="hl-keyword">for</strong> (Member member : setMembers) {
    System.out.println (<font font-style="normal" color="#008000">"isLocalMember "</font> + member.localMember());
    System.out.println (<font font-style="normal" color="#008000">"member.inetaddress "</font> + member.getInetAddress());
    System.out.println (<font font-style="normal" color="#008000">"member.port "</font> + member.getPort());
}

</pre><p>

    </p></div><div class="sect1" title="7.2.&nbsp;Cluster-wide Id Generator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IdGenerator"></a>7.2.&nbsp;Cluster-wide Id Generator</h2></div></div></div><p>
        Hazelcast IdGenerator creates cluster-wide unique IDs. Generated IDs are long type primitive values between 0
        and
        <code class="literal">Long.MAX_VALUE</code>
        . Id generation occurs almost at the speed of
        <code class="literal">AtomicLong.incrementAndGet()</code>
        . Generated IDs are unique during the life cycle of the cluster. If the entire cluster is restarted, IDs start
        from 0 again.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IdGenerator;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;

IdGenerator idGenerator = Hazelcast.getIdGenerator(<font font-style="normal" color="#008000">"customer-ids"</font>);
<strong class="hl-keyword">long</strong> id = idGenerator.newId();
</pre><p>


    </p></div><div class="sect1" title="7.3.&nbsp;LiteMember"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="LiteMember"></a>7.3.&nbsp;LiteMember</h2></div></div></div><p>
        LiteMembers are members with no storage. If
        <code class="literal">-Dhazelcast.lite.member=true</code>
        JVM parameter is set, then the JVM will join the cluster as a 'lite member' which will not be a 'data
        partition' (no data on that node) but will have super fast access to the cluster
        just like any regular member does.
    </p></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Transactions"><div class="titlepage"><div><div><h2 class="title"><a name="Transactions"></a>Chapter&nbsp;8.&nbsp;Transactions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TransactionInterface">8.1. Transaction Interface</a></span></dt><dt><span class="sect1"><a href="#JEEIntegration">8.2. J2EE Integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JEEIntegrationConfig">8.2.1. Resource Adapter Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationGlassfishSample">8.2.2. Sample Glassfish v3 Web Application Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationJBossSample">8.2.3. Sample JBoss Web Application Configuration</a></span></dt></dl></dd></dl></div><div class="sect1" title="8.1.&nbsp;Transaction Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TransactionInterface"></a>8.1.&nbsp;Transaction Interface</h2></div></div></div><p>
        Hazelcast can be used in transactional context. Basically start a transaction, work with queues, maps, sets and
        do other things then commit/rollback in one shot.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Queue;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Set;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Transaction; 

Queue queue = Hazelcast.getQueue(<font font-style="normal" color="#008000">"myqueue"</font>);
Map map     = Hazelcast.getMap  (<font font-style="normal" color="#008000">"mymap"</font>);
Set set     = Hazelcast.getSet  (<font font-style="normal" color="#008000">"myset"</font>);

Transaction txn = Hazelcast.getTransaction();
txn.begin();
<strong class="hl-keyword">try</strong> {    
    Object obj = queue.poll();
    <em class="hl-comment" style="color: silver">//process obj</em>
    map.put (<font font-style="normal" color="#008000">"1"</font>, <font font-style="normal" color="#008000">"value1"</font>);
    set.add (<font font-style="normal" color="#008000">"value"</font>);
    <em class="hl-comment" style="color: silver">//do other things..</em>
    txn.commit();
}<strong class="hl-keyword">catch</strong> (Throwable t)  {
    txn.rollback();
}
</pre><p>

        Isolation is always
        <code class="literal">READ_COMMITTED</code>
        . If you are in a transaction, you can read the data in your transaction and the data that is already committed
        and if not in a transaction, you can only read the committed data. Implementation is different for queue and
        map/set. For queue operations (offer,poll), offered and/or polled objects are copied to the next member in order
        to safely commit/rollback. For map/set, Hazelcast first acquires the locks for the write operations (put,
        remove) and holds the differences (what is added/removed/updated) locally for each transaction. When transaction
        is set to commit, Hazelcast will release the locks and apply the differences. When rolling back, Hazelcast will
        simply releases the locks and discard the differences. Transaction instance is attached to the current thread
        and each Hazelcast operation checks if the current thread holds a transaction, if so, operation will be
        transaction aware. When transaction is committed, rolled back or timed out, it will be detached from the thread
        holding it.

    </p></div><div class="sect1" title="8.2.&nbsp;J2EE Integration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JEEIntegration"></a>8.2.&nbsp;J2EE Integration</h2></div></div></div><p>Hazelcast can be integrated into J2EE containers via Hazelcast Resource Adapter (
        hazelcast-ra.rar ). After proper configuration, Hazelcast can participate in standard J2EE
        transactions.
        </p><pre class="programlisting">&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.resource.ResourceException"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.transaction.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.naming.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.resource.cci.*"</font> %&gt; 
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"java.util.*"</font> %&gt; 
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"com.hazelcast.core.Hazelcast"</font> %&gt; 

&lt;%
UserTransaction txn = null;
Connection conn = null;
Queue queue = Hazelcast.getQueue (<font font-style="normal" color="#008000">"default"</font>);
Map map     = Hazelcast.getMap   (<font font-style="normal" color="#008000">"default"</font>);
Set set     = Hazelcast.getSet   (<font font-style="normal" color="#008000">"default"</font>);
List list   = Hazelcast.getList  (<font font-style="normal" color="#008000">"default"</font>);

<strong class="hl-keyword">try</strong> { 
    Context context = <strong class="hl-keyword">new</strong> InitialContext(); 
    txn = (UserTransaction) context.lookup(<font font-style="normal" color="#008000">"java:comp/UserTransaction"</font>); 
    txn.begin(); 
    
    ConnectionFactory cf = (ConnectionFactory) context.lookup (<font font-style="normal" color="#008000">"java:comp/env/HazelcastCF"</font>); 
    conn = cf.getConnection();  
    
    queue.offer(<font font-style="normal" color="#008000">"newitem"</font>);
    map.put (<font font-style="normal" color="#008000">"1"</font>, <font font-style="normal" color="#008000">"value1"</font>);
    set.add (<font font-style="normal" color="#008000">"item1"</font>);
    list.add (<font font-style="normal" color="#008000">"listitem1"</font>);
    
    txn.commit(); 
} <strong class="hl-keyword">catch</strong> (Throwable e) { 
    <strong class="hl-keyword">if</strong> (txn != null) {
        <strong class="hl-keyword">try</strong> {
            txn.rollback();
        } <strong class="hl-keyword">catch</strong> (Exception ix) {ix.printStackTrace();};
    }
    e.printStackTrace();
} <strong class="hl-keyword">finally</strong> { 
    <strong class="hl-keyword">if</strong> (conn != null) {
        <strong class="hl-keyword">try</strong> {
            conn.close();
        } <strong class="hl-keyword">catch</strong> (Exception ignored) {};
    }
}
%&gt;
</pre><p>
    </p><div class="sect2" title="8.2.1.&nbsp;Resource Adapter Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationConfig"></a>8.2.1.&nbsp;Resource Adapter Configuration</h3></div></div></div><p>Deploying and configuring Hazelcast resource adapter is no different than any other
            resource adapter since it is a standard
            <code class="literal">JCA</code>
            resource adapter but
            resource adapter installation and configuration is container specific, so please consult
            your J2EE vendor documentation for details. Most common steps are:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Add the
                        <code class="literal">hazelcast.jar</code>
                        to container's classpath. Usually
                        there is a lib directory that is loaded automatically by the container on
                        startup.
                    </p></li><li class="listitem"><p>Deploy<code class="literal">hazelcast-ra.rar</code>. Usually there is a some kind of
                        deploy directory. Name of the directory varies by container.
                    </p></li><li class="listitem"><p>Make container specific configurations when/after
                        deploying<code class="literal">hazelcast-ra.rar</code>. Besides container specific
                        configurations,
                        <code class="literal">JNDI</code>
                        name for Hazelcast resource is
                        set.
                    </p></li><li class="listitem"><p>Configure your application to use the Hazelcast resource. Updating
                        <code class="literal">web.xml</code>
                        and/or
                        <code class="literal">ejb-jar.xml</code>
                        to let
                        container know that your application will use the Hazelcast resource and
                        define the resource reference.
                    </p></li><li class="listitem"><p>Make container specific application configuration to specify
                        <code class="literal">JNDI</code>
                        name used for the resource in the application.
                    </p></li></ol></div><p>
        </p></div><div class="sect2" title="8.2.2.&nbsp;Sample Glassfish v3 Web Application Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationGlassfishSample"></a>8.2.2.&nbsp;Sample Glassfish v3 Web Application Configuration</h3></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-&lt;version&gt;.jar</code>
                        into
                        <code class="literal">GLASSFISH_HOME/glassfish/domains/domain1/lib/ext/</code>
                        directory.
                    </p></li><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
                        into
                        <code class="literal">GLASSFISH_HOME/glassfish/domains/domain1/autodeploy/</code>
                        directory
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-type&gt;</font>com.hazelcast.jca.ConnectionFactoryImpl<font font-style="bold" color="#0A1777">&lt;/res-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-auth&gt;</font>Container<font font-style="bold" color="#0A1777">&lt;/res-auth&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font>
</pre><p>
                    </p></li></ol></div><p>
            Notice that we didn't have to put
            <code class="literal">sun-ra.xml</code>
            into the
            rar file because it comes with the
            <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
            file already.
        </p><p>If Hazelcast resource is used from EJBs, you should configure
            <code class="literal">ejb-jar.xml</code>
            for resource reference and
            <code class="literal">JNDI</code>
            definitions, just like we did for<code class="literal">web.xml</code>.
        </p></div><div class="sect2" title="8.2.3.&nbsp;Sample JBoss Web Application Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationJBossSample"></a>8.2.3.&nbsp;Sample JBoss Web Application Configuration</h3></div></div></div><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-&lt;version&gt;.jar</code>
                        into
                        <code class="literal">JBOSS_HOME/server/deploy/default/lib</code>
                        directory.
                    </p></li><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
                        into
                        <code class="literal">JBOSS_HOME/server/deploy/default/deploy</code>
                        directory
                    </p></li><li class="listitem"><p>Create a
                        <code class="literal">hazelcast-ds.xml</code>
                        at
                        <code class="literal">JBOSS_HOME/server/deploy/default/deploy</code>
                        directory
                        containing the following content. Make sure to set the
                        <code class="literal">rar-name</code>
                        element
                        to<code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>.
                        </p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: blue">&lt;!DOCTYPE connection-factories
  PUBLIC "-//JBoss//DTD JBOSS JCA Config 1.5//EN"
  "http://www.jboss.org/j2ee/dtd/jboss-ds_1_5.dtd"&gt;</strong>

<font font-style="bold" color="#0A1777">&lt;connection-factories&gt;</font> 
 <font font-style="bold" color="#0A1777">&lt;tx-connection-factory&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;local-transaction/&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;track-connection-by-tx&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/track-connection-by-tx&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;jndi-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/jndi-name&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;rar-name&gt;</font>hazelcast-ra-<font font-style="bold" color="#0A1777">&lt;version&gt;</font>.rar<font font-style="bold" color="#0A1777">&lt;/rar-name&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;connection-definition&gt;</font>
           javax.resource.cci.ConnectionFactory
      <font font-style="bold" color="#0A1777">&lt;/connection-definition&gt;</font> 
  <font font-style="bold" color="#0A1777">&lt;/tx-connection-factory&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/connection-factories&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-type&gt;</font>com.hazelcast.jca.ConnectionFactoryImpl<font font-style="bold" color="#0A1777">&lt;/res-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-auth&gt;</font>Container<font font-style="bold" color="#0A1777">&lt;/res-auth&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">jboss-web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;jndi-name&gt;</font>java:HazelcastCF<font font-style="bold" color="#0A1777">&lt;/jndi-name&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font> 
</pre><p>
                    </p></li></ul></div><p>
            If Hazelcast resource is used from EJBs, you should configure
            <code class="literal">ejb-jar.xml</code>
            and
            <code class="literal">jboss.xml</code>
            for resource
            reference and
            <code class="literal">JNDI</code>
            definitions.
        </p></div></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Distributed Executor Service"><div class="titlepage"><div><div><h2 class="title"><a name="ExecutorService"></a>Chapter&nbsp;9.&nbsp;Distributed Executor Service</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DistributedExecution">9.1. Distributed Execution</a></span></dt><dt><span class="sect1"><a href="#ExecutionCancellation">9.2. Execution Cancellation</a></span></dt><dt><span class="sect1"><a href="#ExecutionCallback">9.3. Execution Callback</a></span></dt></dl></div><div class="simplesect"><div class="titlepage"></div><p>
    One of the coolest new futures of Java 1.5 is the Executor framework, which allows you to asynchronously execute
    your tasks, logical units of works, such as database query, complex calculation, image rendering etc. So one nice
    way of executing such tasks would be running them asynchronously and doing other things meanwhile. When ready, get
    the result and move on. If execution of the task takes longer than expected, you may consider canceling the task
    execution. In Java Executor framework, tasks are implemented as
    <code class="literal">java.util.concurrent.Callable</code>
    and<code class="literal">java.util.Runnable</code>.

    </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.concurrent.Callable;
<strong class="hl-keyword">import</strong> java.io.Serializable;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Echo <strong class="hl-keyword">implements</strong> Callable&lt;String&gt;, Serializable {
    String input = null;

    <strong class="hl-keyword">public</strong> Echo() {
    }

    <strong class="hl-keyword">public</strong> Echo(String input) {
        <strong class="hl-keyword">this</strong>.input = input;
    }

    <strong class="hl-keyword">public</strong> String call() {
        <strong class="hl-keyword">return</strong> Hazelcast.getCluster().getLocalMember().toString() + <font font-style="normal" color="#008000">":"</font> + input;
    }
}
</pre><p>

    Echo callable above, for instance, in its
    <code class="literal">call()</code>
    method, is returning the local member and the input passed in. Remember that
    <code class="literal">Hazelcast.getCluster().getLocalMember()</code>
    returns the local member and
    <code class="literal">toString()</code>
    returns the member's address
    <code class="literal">(ip + port)</code>
    in String form, just to see which member actually executed the code for our example. Of course, call() method can do
    and return anything you like.

    Executing a task by using executor framework is very straight forward. Simply obtain a
    <code class="literal">ExecutorService</code>
    instance, generally via
    <code class="literal">Executors</code>
    and submit the task which returns a<code class="literal">Future</code>. After executing task, you don't have to wait for
    execution to complete, you can process other things and when ready use the future object to retrieve the result as
    show in code below.

    </p><pre class="programlisting">ExecutorService executorService = Executors.newSingleThreadExecutor();
Future&lt;String&gt; future = executorService.submit (<strong class="hl-keyword">new</strong> Echo(<font font-style="normal" color="#008000">"myinput"</font>));
<em class="hl-comment" style="color: silver">//while it is executing, do some useful stuff</em>
<em class="hl-comment" style="color: silver">//when ready, get the result of your execution</em>
String result = future.get();
</pre><p>
    </p></div><div class="sect1" title="9.1.&nbsp;Distributed Execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DistributedExecution"></a>9.1.&nbsp;Distributed Execution</h2></div></div></div><p>Distributed executor service is a distributed implementation of java.util.concurrent.ExecutorService.
        It allows you to execute your code in cluster. In this chapter, all the code samples are based on the Echo class
        above.
        Please note that Echo class is
        <code class="literal">Serializable</code>
        .
        You can ask Hazelcast to execute your code (<code class="literal">Runnable, Callable</code>):
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>on a specific cluster member you choose.
                </p></li><li class="listitem"><p>on the member owning the key you choose.
                </p></li><li class="listitem"><p>on the member Hazelcast will pick.
                </p></li><li class="listitem"><p>on all or subset of the cluster members.
                </p></li></ul></div><p>
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Member;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.MultiTask;
<strong class="hl-keyword">import</strong> com.hazelcast.core.DistributedTask;
<strong class="hl-keyword">import</strong> java.util.concurrent.ExecutorService;   
<strong class="hl-keyword">import</strong> java.util.concurrent.FutureTask;   
<strong class="hl-keyword">import</strong> java.util.concurrent.Future;   
<strong class="hl-keyword">import</strong> java.util.Set;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnTheMember(String input, Member member) <strong class="hl-keyword">throws</strong> Exception {
   FutureTask&lt;String&gt; task = <strong class="hl-keyword">new</strong> DistributedTask&lt;String&gt;(<strong class="hl-keyword">new</strong> Echo(input), member);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   String echoResult = task.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnTheMemberOwningTheKey(String input, Object key) <strong class="hl-keyword">throws</strong> Exception {
   FutureTask&lt;String&gt; task = <strong class="hl-keyword">new</strong> DistributedTask&lt;String&gt;(<strong class="hl-keyword">new</strong> Echo(input), key);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   String echoResult = task.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnSomewhere(String input) <strong class="hl-keyword">throws</strong> Exception { 
   ExecutorService executorService = Hazelcast.getExecutorService();
   Future&lt;String&gt; task = executorService.submit(<strong class="hl-keyword">new</strong> Echo(input));
   String echoResult = task.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnMembers(String input, Set&lt;Member&gt; members) <strong class="hl-keyword">throws</strong> Exception {
   MultiTask&lt;String&gt; task = <strong class="hl-keyword">new</strong> MultiTask&lt;String&gt;(<strong class="hl-keyword">new</strong> Echo(input), members);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   Collection&lt;String&gt; results = task.get();
} 
</pre><p>
        Note that you can obtain the set of cluster members via
        <code class="literal">Hazelcast.getCluster().getMembers()</code>
        call.
        You can also extend the
        <code class="literal">MultiTask</code>
        class to override
        <code class="literal">set(V result), setException(Throwable exception), done()</code>
        methods for custom behaviour.
        Just like
        <code class="literal">java.util.concurrent.FutureTask.get() , MultiTask.get()</code>
        will throw
        <code class="literal">java.util.concurrent.ExecutionException</code>
        if any of the executions throws exception.

    </p></div><div class="sect1" title="9.2.&nbsp;Execution Cancellation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExecutionCancellation"></a>9.2.&nbsp;Execution Cancellation</h2></div></div></div><p>What if the code you execute in cluster takes longer than acceptable. If you cannot
        stop/cancel that task it will keep eating your resources. Standard Java executor framework
        solves this problem with by introducing
        <code class="literal">cancel()</code>
        api and 'encouraging' us
        to code and design for cancellations, which is highly ignored part of software development.
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Fibonacci <strong class="hl-keyword">implements</strong> Callable&lt;Long&gt;, Serializable {
    <strong class="hl-keyword">int</strong> input = <span class="hl-number">0</span>; 

    <strong class="hl-keyword">public</strong> Fibonacci() { 
    } 

    <strong class="hl-keyword">public</strong> Fibonacci(<strong class="hl-keyword">int</strong> input) { 
        <strong class="hl-keyword">this</strong>.input = input;
    } 

    <strong class="hl-keyword">public</strong> Long call() {
        <strong class="hl-keyword">return</strong> calculate (input);
    }

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> calculate (<strong class="hl-keyword">int</strong> n) {
        <strong class="hl-keyword">if</strong> (Thread.currentThread().isInterrupted()) <strong class="hl-keyword">return</strong> <span class="hl-number">0</span>;
        <strong class="hl-keyword">if</strong> (n &lt;= <span class="hl-number">1</span>) <strong class="hl-keyword">return</strong> n;
        <strong class="hl-keyword">else</strong> <strong class="hl-keyword">return</strong> calculate(n-<span class="hl-number">1</span>) + calculate(n-<span class="hl-number">2</span>);
    }
}
</pre><p>
        The callable class above calculates the fibonacci number for a given number. In
        the calculate method, we are checking to see if the current thread is interrupted so that
        code can be responsive to cancellations once the execution started. Following
        <code class="literal">fib()</code>
        method submits the Fibonacci calculation task for number 'n'
        and waits maximum 3 seconds for result. If the execution doesn't complete in 3 seconds,
        <code class="literal">future.get()</code>
        will throw
        <code class="literal">TimeoutException</code>
        and upon
        catching it we interruptibly cancel the execution for saving some CPU cycles.
        </p><pre class="programlisting"><strong class="hl-keyword">long</strong> fib(<strong class="hl-keyword">int</strong> n) <strong class="hl-keyword">throws</strong> Exception {
    ExecutorService es = Hazelcast.getExecutorService();
    Future future = es.submit(<strong class="hl-keyword">new</strong> Fibonacci(n));  
    <strong class="hl-keyword">try</strong> {
        <strong class="hl-keyword">return</strong> future.get(<span class="hl-number">3</span>, TimeUnit.SECONDS);
    } <strong class="hl-keyword">catch</strong> (TimeoutException e) {
        future.cancel(true);            
    }
    <strong class="hl-keyword">return</strong> -<span class="hl-number">1</span>;
}
</pre><p>
        <code class="literal">fib(20)</code>
        will probably will take less than 3 seconds but
        <code class="literal">fib(50)</code>
        will take
        way longer. (This is not the example for writing better fibonacci calculation code but for
        showing how to cancel a running execution that takes too long.)
        <code class="literal">future.cancel(false)</code>
        can
        only cancel execution before it is running (executing) but
        <code class="literal">future.cancel(true)</code>
        can
        interrupt running executions if your code is able to handle the interruption. So if you are
        willing to be able to cancel already running task then your task has to be designed to
        handle interruption. If
        <code class="literal">calculate (int n)</code>
        method didn't have if
        <code class="literal">(Thread.currentThread().isInterrupted())</code>
        line, then you wouldn't be
        able to cancel the execution after it started.
    </p></div><div class="sect1" title="9.3.&nbsp;Execution Callback"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExecutionCallback"></a>9.3.&nbsp;Execution Callback</h2></div></div></div><p>
        <code class="literal">ExecutionCallback</code>
        allows you to asynchronously get notified when the execution is done.
        When implementing
        <code class="literal">ExecutionCallback.done(Future)</code>
        method, you can check if the task is
        already cancelled.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.ExecutionCallback;
<strong class="hl-keyword">import</strong> com.hazelcast.core.DistributedTask;
<strong class="hl-keyword">import</strong> java.util.concurrent.ExecutorService;    
<strong class="hl-keyword">import</strong> java.util.concurrent.Future; 
        
ExecutorService es = Hazelcast.getExecutorService();
DistributedTask&lt;String&gt; task = <strong class="hl-keyword">new</strong> DistributedTask&lt;String&gt;(<strong class="hl-keyword">new</strong> Fibonacci(<span class="hl-number">10</span>));
task.setExecutionCallback(<strong class="hl-keyword">new</strong> ExecutionCallback&lt;Long&gt; () {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> done (Future&lt;Long&gt; future) { 
        <strong class="hl-keyword">try</strong> {
            <strong class="hl-keyword">if</strong> (! future.isCancelled()) {
                System.out.println(<font font-style="normal" color="#008000">"Fibonacci calculation result = "</font> + future.get());
            }
        } <strong class="hl-keyword">catch</strong> (Exception e) {
            e.printStackTrace();
        }
    }
});
es.execute(task);
</pre><p>
        You could have achieved the same results by extending
        <code class="literal">DistributedTask</code>
        and overriding the
        <code class="literal">DistributedTask.done()</code>
        method.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.DistributedTask;
<strong class="hl-keyword">import</strong> java.util.concurrent.ExecutorService;    
<strong class="hl-keyword">import</strong> java.util.concurrent.Future; 
        
ExecutorService es = Hazelcast.getExecutorService();
es.execute(<strong class="hl-keyword">new</strong> DistributedTask&lt;String&gt;(<strong class="hl-keyword">new</strong> Fibonacci(<span class="hl-number">10</span>)) {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> done () { 
        <strong class="hl-keyword">try</strong> {
            <strong class="hl-keyword">if</strong> (! isCancelled()) {
                System.out.println(<font font-style="normal" color="#008000">"Fibonacci calculation result = "</font> + get());
            }
        } <strong class="hl-keyword">catch</strong> (Exception e) {
            e.printStackTrace();
        }
    }
}); 
</pre><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Http Session Clustering with HazelcastWM"><div class="titlepage"><div><div><h2 class="title"><a name="HttpSessionClustering"></a>Chapter&nbsp;10.&nbsp;Http Session Clustering with HazelcastWM</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    Say you have more than one web servers (A, B, C) with a load balancer in front of them. If server A goes down
    then your users on that server will be directed to one of the live servers (B or C) but their sessions will be lost!
    So we have to have all these sessions backed up somewhere if we don't want to lose the sessions upon server crashes.
    Hazelcast WM allows you to cluster user http sessions automatically. The following are required for enabling
    Hazelcast Session Clustering:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Target application or web server should support Java 1.5+
            </p></li><li class="listitem"><p>Target application or web server should support Servlet 2.4+ spec
            </p></li><li class="listitem"><p>Session objects that needs to be clustered have to be Serializable
            </p></li></ul></div><p>
    Here are the steps to setup Hazelcast Session Clustering:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Put the
                <code class="literal">hazelcast</code>
                and
                <code class="literal">hazelcast-wm</code>
                jars in your
                <code class="literal">WEB-INF/lib</code>
                directory. Optionally if you wish to connect to a cluster as a client add
                <code class="literal">hazelcast-client</code>
                as well.
            </p></li><li class="listitem"><p>Put the following xml into
                <code class="literal">web.xml</code>
                file. Make sure Hazelcast filter is placed
                before all the other filters if any; put it at the top for example.
            </p><p>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;filter&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-name&gt;</font>hazelcast-filter<font font-style="bold" color="#0A1777">&lt;/filter-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-class&gt;</font>com.hazelcast.web.WebFilter<font font-style="bold" color="#0A1777">&lt;/filter-class&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Name of the distributed map storing
        your web session objects
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>map-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>my-sessions<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        How is your load-balancer configured?
        stick-session means all requests of a session
        is routed to the node where the session is first created.
        This is excellent for performance.
        If sticky-session is set to false, when a session is updated
        on a node, entry for this session on all other nodes is invalidated.
        You have to know how your load-balancer is configured before
        setting this parameter. Default is true.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>sticky-session<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Name of session id cookie
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>hazelcast.sessionId<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Domain of session id cookie. Default is based on incoming request.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-domain<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>.mywebsite.com<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Should cookie only be sent using a secure protocol? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-secure<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Should HttpOnly attribute be set on cookie ? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-http-only<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Are you debugging? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>debug<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Configuration xml location;
            * as servlet resource OR
            * as classpath resource OR
            * as URL
        Default is one of hazelcast-default.xml
        or hazelcast.xml in classpath.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>config-location<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>/WEB-INF/hazelcast.xml<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to use an existing HazelcastInstance?
        Default is null.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>instance-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>default<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
</pre><p>
 
</p><pre class="programlisting">
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to connect as a client to an existing cluster?
        Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>use-client<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Client configuration location;
            * as servlet resource OR
            * as classpath resource OR
            * as URL
        Default is null.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>client-config-location<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>/WEB-INF/hazelcast-client.properties<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to shutdown HazelcastInstance during
        web application undeploy process?
        Default is true.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>shutdown-on-destroy<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/filter&gt;</font>
<font font-style="bold" color="#0A1777">&lt;filter-mapping&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-name&gt;</font>hazelcast-filter<font font-style="bold" color="#0A1777">&lt;/filter-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;url-pattern&gt;</font>/*<font font-style="bold" color="#0A1777">&lt;/url-pattern&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>FORWARD<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>INCLUDE<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>REQUEST<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/filter-mapping&gt;</font>

<font font-style="bold" color="#0A1777">&lt;listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;listener-class&gt;</font>com.hazelcast.web.SessionListener<font font-style="bold" color="#0A1777">&lt;/listener-class&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>Package and deploy your war file as you would normally do.
            </p></li></ol></div><p>

    It is that easy! All http requests will go through Hazelcast
    <code class="literal">WebFilter</code>
    and it will put the
    session objects into Hazelcast distributed map if needed.
    </p><p>
        <span class="bold"><strong>Info about sticky-sessions:</strong></span>
    </p><p>
        Hazelcast holds whole session attributes in a distributed map and in local http session. Local session is required
        for fast access to data and distributed map is needed for fail-safety.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="italic">If sticky-session is not used, whenever a session a attribute
                    is updated in a node (in both node local session and clustered cache),
                    that attribute should be invalidated in all other nodes' local sessions,
                    because now they have dirty value. So when a request arrives one of those other nodes
                    that attribute value is fetched from clustered cache.</span>
                </p></li><li class="listitem"><p>
                    <span class="italic">To overcome performance penalty of sending invalidation messages during updates,
                        sticky-sessions can be used.
                        If Hazelcast knows sessions are sticky, invalidation will not be send, because Hazelcast assumes there is
                        no other local session at the moment. When a server is down, requests belonging to a session hold
                        in that server will routed to other one and that server will fetch session data from clustered cache.
                        That means using sticky-sessions, one will not suffer performance penalty of accessing clustered data
                        and can benefit recover from a server failure.</span>
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;WAN Replication"><div class="titlepage"><div><div><h2 class="title"><a name="WanReplication"></a>Chapter&nbsp;11.&nbsp;WAN Replication</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        There are cases where you would need to synchronize multiple clusters. Synchronization of clusters
        is named as WAN (Wide Area Network) Replication because it is mainly used for replicating different
        clusters running on WAN. Imagine having different clusters in New York, London and Tokyo.
        Each cluster would be operating at very high speed in their LAN (Local Area Network) settings but you would
        want some or all parts of the data in these clusters replicating to each other.
        So updates in Tokyo cluster goes to London and NY,
        in the meantime updates in New York cluster is synchronized to Tokyo and London.
    </p><p>
        You can setup active-passive WAN
        Replication where only one active node replicating its updates on the passive one. You can also setup
        active-active replication where each cluster is actively updating and replication to the other cluster(s).
    </p><p>
        In the active-active replication setup, there might be cases where each node is updating the same entry in the
        same named distributed map. Thus, conflicts will occur when merging. For those cases, conflict-resolution
        will be needed. Here is how you can setup WAN Replication for London cluster for instance:
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;wan-replication</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;target-cluster</font> <font font-style="bold" color="#0A1777">group-name</font>=<font font-style="bold" color="#008000">"tokyo"</font> <font font-style="bold" color="#0A1777">group-password</font>=<font font-style="bold" color="#008000">"tokyo-pass"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;replication-impl&gt;</font>com.hazelcast.impl.wan.WanNoDelayReplication<font font-style="bold" color="#0A1777">&lt;/replication-impl&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;end-points&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.2.1.1:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.2.1.2:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/end-points&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/target-cluster&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;target-cluster</font> <font font-style="bold" color="#0A1777">group-name</font>=<font font-style="bold" color="#008000">"london"</font> <font font-style="bold" color="#0A1777">group-password</font>=<font font-style="bold" color="#008000">"london-pass"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;replication-impl&gt;</font>com.hazelcast.impl.wan.WanNoDelayReplication<font font-style="bold" color="#0A1777">&lt;/replication-impl&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;end-points&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.3.5.1:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.3.5.2:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/end-points&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/target-cluster&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/wan-replication&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>

<font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        This can be the configuration of the cluster running in NY, replicating to Tokyo and London.
        Tokyo and London clusters should have similar configurations if they are also active replicas.
    </p><p>
        If NY and London cluster configurations contain
        <code class="literal">wan-replication</code>
        element and
        Tokyo cluster doesn't then it means NY and London are active endpoints and Tokyo is passive endpoint.
    </p><p>
        As noted earlier you can have Hazelcast replicate some or all of the data in your clusters. You might have
        5 different distributed maps but you might want only one of these maps replicating across clusters.
        So you mark which maps to replicate by adding
        <code class="literal">wan-replication-ref</code>
        element into map configuration.
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;wan-replication</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/wan-replication&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-shared-map"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;wan-replication-ref</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;merge-policy&gt;</font>hz.PASS_THROUGH<font font-style="bold" color="#0A1777">&lt;/merge-policy&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/wan-replication-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        Here we have
        <code class="literal">my-shared-map</code>
        is configured to replicate itself to the cluster targets defined
        in the
        <code class="literal">wan-replication</code>
        element.
    </p><p>
        Note that you will also need to define a
        <code class="literal">merge policy</code>
        for merging replica entries and resolving conflicts
        during the merge. Default merge policy is
        <code class="literal">hz.PASS_THROUGH</code>
        which will apply all in-coming updates as is.
    </p></div></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="Config"></a>Chapter&nbsp;12.&nbsp;Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ConfigGroup">12.1. Creating Separate Clusters</a></span></dt><dt><span class="sect1"><a href="#NetworkConfig">12.2. Network Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConfigTcpIp">12.2.1. Configuring TCP/IP Cluster</a></span></dt><dt><span class="sect2"><a href="#ConfigSpecifyInterfaces">12.2.2. Specifying Network Interfaces</a></span></dt><dt><span class="sect2"><a href="#EC2AutoDiscovery">12.2.3. EC2 Auto Discovery</a></span></dt><dt><span class="sect2"><a href="#NetworkPartitioning">12.2.4. Network Partitioning (Split-Brain Syndrome)</a></span></dt><dt><span class="sect2"><a href="#SSL">12.2.5. SSL</a></span></dt><dt><span class="sect2"><a href="#Encryption">12.2.6. Encryption</a></span></dt><dt><span class="sect2"><a href="#SocketInterceptor">12.2.7. Socket Interceptor</a></span></dt><dt><span class="sect2"><a href="#IPv6">12.2.8. IPv6 Support</a></span></dt><dt><span class="sect2"><a href="#OutboundPorts">12.2.9. Restricting Outbound Ports</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PartitionGroupConfig">12.3. Partition Group Configuration</a></span></dt><dt><span class="sect1"><a href="#ListenerConfig">12.4. Listener Configurations</a></span></dt><dt><span class="sect1"><a href="#WildcardConfiguration">12.5. Wildcard Configuration</a></span></dt><dt><span class="sect1"><a href="#ConfigurationProperties">12.6. Advanced Configuration Properties</a></span></dt><dt><span class="sect1"><a href="#Logging">12.7. Logging Configuration</a></span></dt><dt><span class="sect1"><a href="#EnterpriseConfig">12.8. Setting License Key <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></div><p>
    Hazelcast can be configured through xml or using configuration api or even mix of both.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="bold"><strong>Xml Configuration</strong></span>
            </p><p>If you are using default Hazelcast instance
                (<code class="literal">Hazelcast.getDefaultInstance()</code>) or creating new Hazelcast
                instance with passing
                <code class="literal">null</code>
                parameter
                (<code class="literal">Hazelcast.newHazelcastInstance(null)</code>), Hazelcast will look
                into two places for the configuration file:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <span class="bold"><strong>System property:</strong></span>
                            Hazelcast will first
                            check if "<code class="literal">hazelcast.config</code>" system property is set to
                            a file path. Example:
                            <code class="literal">-Dhazelcast.config=C:/myhazelcast.xml</code>.
                        </p></li><li class="listitem"><p>
                            <span class="bold"><strong>Classpath:</strong></span>
                            If config file is not set
                            as a system property, Hazelcast will check classpath for
                            <span class="bold"><strong>
                                <code class="literal">hazelcast.xml</code>
                            </strong></span>
                            file.
                        </p></li></ul></div><p>
                If Hazelcast doesn't find any config file, it will happily start with
                default configuration (<code class="literal">hazelcast-default.xml</code>) located in
                <code class="literal">hazelcast.jar</code>. (Before configuring Hazelcast, please try to
                work with default configuration to see if it works for you. Default should be just
                fine for most of the users. If not, then consider custom configuration for your
                environment.)
            </p><p>
                If you want to specify your own configuration file to create
                <code class="literal">Config</code>, Hazelcast supports several ways including filesystem,
                classpath, InputStream, URL etc.:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                XmlConfigBuilder(xmlFileName).build();
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                XmlConfigBuilder(inputStream).build();
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                ClasspathXmlConfig(xmlFileName);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                FileSystemXmlConfig(configFilename);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                UrlXmlConfig(url);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                InMemoryXmlConfig(xml);
                            </code>
                        </p></li></ul></div><p>
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Programmatic Configuration</strong></span>
            </p><p>To configure Hazelcast programatically, just instantiate a
                <code class="literal">Config</code> object and set/change its properties/attributes due to
                your needs.
                </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
cfg.setPort(<span class="hl-number">5900</span>);
cfg.setPortAutoIncrement(false);
        
NetworkConfig network = cfg.getNetworkConfig();
Join join = network.getJoin();
join.getMulticastConfig().setEnabled(false);
join.getTcpIpConfig().addMember(<font font-style="normal" color="#008000">"10.45.67.32"</font>).addMember(<font font-style="normal" color="#008000">"10.45.67.100"</font>)
            .setRequiredMember(<font font-style="normal" color="#008000">"192.168.10.100"</font>).setEnabled(true);
network.getInterfaces().setEnabled(true).addInterface(<font font-style="normal" color="#008000">"10.45.67.*"</font>);
        
MapConfig mapCfg = <strong class="hl-keyword">new</strong> MapConfig();
mapCfg.setName(<font font-style="normal" color="#008000">"testMap"</font>);
mapCfg.setBackupCount(<span class="hl-number">2</span>);
mapCfg.getMaxSizeConfig().setSize(<span class="hl-number">10000</span>);
mapCfg.setTimeToLiveSeconds(<span class="hl-number">300</span>);
        
MapStoreConfig mapStoreCfg = <strong class="hl-keyword">new</strong> MapStoreConfig();
mapStoreCfg.setClassName(<font font-style="normal" color="#008000">"com.hazelcast.examples.DummyStore"</font>).setEnabled(true);
mapCfg.setMapStoreConfig(mapStoreCfg);

NearCacheConfig nearCacheConfig = <strong class="hl-keyword">new</strong> NearCacheConfig();
nearCacheConfig.setMaxSize(<span class="hl-number">1000</span>).setMaxIdleSeconds(<span class="hl-number">120</span>).setTimeToLiveSeconds(<span class="hl-number">300</span>);
mapCfg.setNearCacheConfig(nearCacheConfig);

cfg.addMapConfig(mapCfg);</pre><p>
            </p></li></ol></div><p>
    After creating
    <code class="literal">Config</code>
    object, you can use it to initialize
    default Hazelcast instance or create a new Hazelcast instance.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <code class="code">Hazelcast.init(cfg);</code>
            </p></li><li class="listitem"><p>
                <code class="code">Hazelcast.newHazelcastInstance(cfg);</code>
            </p></li></ul></div><p>
    <a name="NamedHazelcastInstance"></a>
    </p><div class="itemizedlist" title="HazelcastInstance with a name:"><p class="title"><b><a class="link" href="#NamedHazelcastInstance">HazelcastInstance with a name</a>:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>To create a named
                <code class="literal">HazelcastInstance</code>
                you should set
                <code class="code">instanceName</code>
                of
                <code class="literal">Config</code>
                object.
            </p><p>
                </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
config.setInstanceName(<font font-style="normal" color="#008000">'my-instance'</font>);
Hazelcast.newHazelcastInstance(config);</pre><p>
            </p></li><li class="listitem"><p>To retrieve an existing
                <code class="literal">HazelcastInstance</code>
                using its name, use;
            </p><p>
                <code class="code">Hazelcast.getHazelcastInstanceByName('my-instance');</code>
            </p></li><li class="listitem"><p>To retrieve all existing<code class="literal">HazelcastInstance</code>s, use;
            </p><p>
                <code class="code">Hazelcast.getAllHazelcastInstances();</code>
            </p></li></ul></div><p>

</p><div class="sect1" title="12.1.&nbsp;Creating Separate Clusters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigGroup"></a>12.1.&nbsp;Creating Separate Clusters</h2></div></div></div><p>
        By specifying group-name and group-password, you can separate your clusters in a simple way; dev group,
        production group, test group, app-a group etc...

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;name&gt;</font>dev<font font-style="bold" color="#0A1777">&lt;/name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;password&gt;</font>dev-pass<font font-style="bold" color="#0A1777">&lt;/password&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/group&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p><p>
        You can also set the groupName with
        <code class="literal">Config</code>
        API.
        JVM can host multiple Hazelcast instances (nodes).
        Each node can only participate in one group and it only joins to
        its own group, does not mess with others. Following code creates 3 separate
        Hazelcast nodes,
        <code class="literal">h1</code>
        belongs to
        <code class="literal">app1</code>
        cluster, while
        <code class="literal">h2</code>
        and
        <code class="literal">h3</code>
        are belong to
        <code class="literal">app2</code>
        cluster.
        </p><pre class="programlisting">
Config configApp1 = <strong class="hl-keyword">new</strong> Config();
configApp1.getGroupConfig().setName(<font font-style="normal" color="#008000">"app1"</font>);

Config configApp2 = <strong class="hl-keyword">new</strong> Config();
configApp2.getGroupConfig().setName(<font font-style="normal" color="#008000">"app2"</font>);

HazelcastInstance h1 = Hazelcast.newHazelcastInstance(configApp1);
HazelcastInstance h2 = Hazelcast.newHazelcastInstance(configApp2);
HazelcastInstance h3 = Hazelcast.newHazelcastInstance(configApp2);
</pre><p>
    </p></div><div class="sect1" title="12.2.&nbsp;Network Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NetworkConfig"></a>12.2.&nbsp;Network Configuration</h2></div></div></div><div class="sect2" title="12.2.1.&nbsp;Configuring TCP/IP Cluster"><div class="titlepage"><div><div><h3 class="title"><a name="ConfigTcpIp"></a>12.2.1.&nbsp;Configuring TCP/IP Cluster</h3></div></div></div><p>If multicast is not preferred way of discovery for your environment, then you can configure Hazelcast for full
        TCP/IP cluster. As configuration below shows, while
        <code class="literal">enable</code>
        attribute of
        <code class="literal">multicast</code>
        is set to false,
        <code class="literal">tcp-ip</code>
        has to be set to true. For the none-multicast option, all or subset of cluster members' hostnames and/or ip
        addresses must be listed. Note that all of the cluster members don't have to be listed there but at least one of
        them has to be active in cluster when a new member joins. The tcp-ip tag accepts an attribute called
        "conn-timeout-seconds".
        The default value is 5. Increasing this value is recommended if you have many IP's listed and members
        can not properly build up the cluster.

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>224.2.2.3<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hostname&gt;</font>machine1<font font-style="bold" color="#0A1777">&lt;/hostname&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hostname&gt;</font>machine2<font font-style="bold" color="#0A1777">&lt;/hostname&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hostname&gt;</font>machine3:5799<font font-style="bold" color="#0A1777">&lt;/hostname&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.0-7<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>     
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.21<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font> 
            <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p></div><div class="sect2" title="12.2.2.&nbsp;Specifying Network Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="ConfigSpecifyInterfaces"></a>12.2.2.&nbsp;Specifying Network Interfaces</h3></div></div></div><p>
        You can also specify which network interfaces that Hazelcast should use. Servers mostly have more than one
        network
        interface so you may want to list the valid IPs. Range characters ('*' and '-') can be used for simplicity. So
        10.3.10.*, for instance, refers to IPs between 10.3.10.0 and 10.3.10.255. Interface 10.3.10.4-18 refers to IPs
        between 10.3.10.4 and 10.3.10.18 (4 and 18 included). If network interface configuration is enabled (disabled by
        default) and if Hazelcast cannot find an matching interface, then it will print a message on console and won't
        start on that node.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ....
        <font font-style="bold" color="#0A1777">&lt;interfaces</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.16.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font> 
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.10.4-18<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font> 
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.3<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>         
        <font font-style="bold" color="#0A1777">&lt;/interfaces&gt;</font>    
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font> 
</pre><p>


    </p></div><div class="sect2" title="12.2.3.&nbsp;EC2 Auto Discovery"><div class="titlepage"><div><div><h3 class="title"><a name="EC2AutoDiscovery"></a>12.2.3.&nbsp;EC2 Auto Discovery</h3></div></div></div><p>Hazelcast supports EC2 Auto Discovery as of 1.9.4. It is useful when you don't want or
        can't provide the list of possible IP addresses. Here is a sample configuration:
        Disable join over multicast and tcp/ip and enable aws. Also provide the credentials.
        The aws tag accepts an attribute called "conn-timeout-seconds". The default value is 5.
        Increasing this value is recommended if you have many IP's listed and members can not properly build up the
        cluster.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;join&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>224.2.2.3<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.2<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;aws</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;access-key&gt;</font>my-access-key<font font-style="bold" color="#0A1777">&lt;/access-key&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;secret-key&gt;</font>my-secret-key<font font-style="bold" color="#0A1777">&lt;/secret-key&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;region&gt;</font>us-west-1<font font-style="bold" color="#0A1777">&lt;/region&gt;</font>                              <em class="hl-comment" style="color: silver">&lt;!-- optional, default is us-east-1 --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;host-header&gt;</font>ec2.amazonaws.com<font font-style="bold" color="#0A1777">&lt;/host-header&gt;</font>              <em class="hl-comment" style="color: silver">&lt;!-- optional, default is ec2.amazonaws.com.
                                                If set, region shouldn't be set as it will override this property --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;security-group-name&gt;</font>hazelcast-sg<font font-style="bold" color="#0A1777">&lt;/security-group-name&gt;</font> <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;tag-key&gt;</font>type<font font-style="bold" color="#0A1777">&lt;/tag-key&gt;</font>                                  <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;tag-value&gt;</font>hz-nodes<font font-style="bold" color="#0A1777">&lt;/tag-value&gt;</font>                          <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;/aws&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
</pre><p>
        You need to add hazelcast-cloud.jar dependency into your project. Note that it is
        also bundled inside hazelcast-all.jar. hazelcast-cloud module doesn't depend on any other third party modules.
    </p></div><div class="sect2" title="12.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)"><div class="titlepage"><div><div><h3 class="title"><a name="NetworkPartitioning"></a>12.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)</h3></div></div></div><p>Imagine that you have 10-node cluster and for some reason the network is divided into two
        in a way that 4 servers cannot see the other 6. As a result you ended up having two separate
        clusters; 4-node cluster and 6-node cluster. Members in each sub-cluster are thinking that
        the other nodes are dead even though they are not. This situation is called Network
        Partitioning (aka Split-Brain Syndrome).
    </p><p>Since it is a network failure, there is no way to avoid it programatically and your
        application will run as two separate independent clusters but we should be able answer the
        following questions: "What will happen after the network failure is fixed and connectivity
        is restored between these two clusters? Will these two clusters merge into one again? If
        they do, how are the data conflicts resolved, because you might end up having two different
        values for the same key in the same map?"
    </p><p>Here is how Hazelcast deals with it:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The oldest member of the cluster checks if there is another cluster with the
                    same group-name and group-password in the network.
                </p></li><li class="listitem"><p>If the oldest member founds such cluster, then figures out which cluster
                    should merge to the other.
                </p></li><li class="listitem"><p>Each member of the merging cluster will do the followings</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>pause
                        </p></li><li class="listitem"><p>take locally owned map entries</p></li><li class="listitem"><p>close all its network connections (detach from its cluster)</p></li><li class="listitem"><p>join to the new cluster</p></li><li class="listitem"><p>send merge request for each its locally owned map entry</p></li><li class="listitem"><p>resume
                        </p></li></ul></div></li></ol></div><p>
        So each member of the merging cluster is actually rejoining to the new
        cluster and sending merge request for each its locally owned map entry.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">Q: Which cluster will merge into the
                other?
            </span>
        </strong></span>
    </p><p>A. Smaller cluster will merge into the bigger one. If they have equal number of members
        then a hashing algorithm determines the merging cluster.
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Q. Each cluster may have different versions
                of the same key in the same map. How is the conflict
                resolved?
            </strong></span>
        </span>
    </p><p>A. Destination cluster will decide how to handle merging entry based on the
        <code class="literal">MergePolicy</code>
        set for that map. There are built-in merge policies such
        as
        <code class="literal">hz.NO_MERGE, hz.ADD_NEW_ENTRY and hz.LATEST_UPDATE</code>
        but you can develop
        your own merge policy by implementing<code class="literal">com.hazelcast.merge.MergePolicy</code>. You
        should register your custom merge policy in the configuration so that Hazelcast can find it
        by name.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> MergePolicy {
    <strong class="hl-tag" style="color: blue">/**
    * Returns the value of the entry after the merge
    * of entries with the same key. Returning value can be
    * You should consider the case where existingEntry is null.
    *
    * @param mapName       name of the map
    * @param mergingEntry  entry merging into the destination cluster
    * @param existingEntry existing entry in the destination cluster
    * @return final value of the entry. If returns null then no change on the entry.
    */</strong>
    Object merge(String mapName, MapEntry mergingEntry, MapEntry existingEntry);
}</pre><p>
     </p><p>
        Here is how merge policies are registered and specified per map.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>NONE<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;eviction-percentage&gt;</font>25<font font-style="bold" color="#0A1777">&lt;/eviction-percentage&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            While recovering from split-brain (network partitioning),
            map entries in the small cluster will merge into the bigger cluster
            based on the policy set here. When an entry merge into the
            cluster, there might an existing entry with the same key already.
            Values of these entries might be different for that same key.
            Which value should be set for the key? Conflict is resolved by
            the policy set here. Default policy is hz.ADD_NEW_ENTRY

            There are built-in merge policies such as
            hz.NO_MERGE      ; no entry will merge.
            hz.ADD_NEW_ENTRY ; entry will be added if the merging entry's key
                               doesn't exist in the cluster.
            hz.HIGHER_HITS   ; entry with the higher hits wins.
            hz.LATEST_UPDATE ; entry with the latest update wins.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;merge-policy&gt;</font>MY_MERGE_POLICY<font font-style="bold" color="#0A1777">&lt;/merge-policy&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;merge-policies&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;map-merge-policy</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"MY_MERGE_POLICY"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.acme.MyOwnMergePolicy<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-merge-policy&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/merge-policies&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p></div><div class="sect2" title="12.2.5.&nbsp;SSL"><div class="titlepage"><div><div><h3 class="title"><a name="SSL"></a>12.2.5.&nbsp;SSL</h3></div></div></div><p>
    Hazelcast allows you to use SSL socket communication among all Hazelcast
    members. You need to implement <code class="code">com.hazelcast.nio.ssl.SSLContextFactory</code>
    and configure SSL section in network configuration.

    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySSLContextFactory <strong class="hl-keyword">implements</strong> SSLContextFactory {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init(Properties properties) <strong class="hl-keyword">throws</strong> Exception {
    }

    <strong class="hl-keyword">public</strong> SSLContext getSSLContext() {
        ...
        SSLContext sslCtx = SSLContext.getInstance(protocol);
        <strong class="hl-keyword">return</strong> sslCtx;
    }
}
</pre><p>

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;ssl</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;factory-class-name&gt;</font>com.hazelcast.examples.MySSLContextFactory<font font-style="bold" color="#0A1777">&lt;/factory-class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"foo"</font><font font-style="bold" color="#0A1777">&gt;</font>bar<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/ssl&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    Hazelcast provides a default SSLContextFactory; <code class="code">com.hazelcast.nio.ssl.BasicSSLContextFactory</code> which
    uses configured keystore to initialize <code class="code">SSLContext</code>. All required is to define <code class="literal">keyStore</code> and
    <code class="literal">keyStorePassword</code>. Also you can set <code class="literal">keyManagerAlgorithm</code> (default <code class="code">SunX509</code>),
    <code class="literal">trustManagerAlgorithm</code> (default <code class="code">SunX509</code>) and <code class="literal">protocol</code> (default <code class="code">TLS</code>).

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;ssl</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;factory-class-name&gt;</font>com.hazelcast.nio.ssl.BasicSSLContextFactory<font font-style="bold" color="#0A1777">&lt;/factory-class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyStore"</font><font font-style="bold" color="#0A1777">&gt;</font>keyStore<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyStorePassword"</font><font font-style="bold" color="#0A1777">&gt;</font>keyStorePassword<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyManagerAlgorithm"</font><font font-style="bold" color="#0A1777">&gt;</font>SunX509<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"trustManagerAlgorithm"</font><font font-style="bold" color="#0A1777">&gt;</font>SunX509<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"protocol"</font><font font-style="bold" color="#0A1777">&gt;</font>TLS<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/ssl&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    You can also set <code class="literal">keyStore</code> and <code class="literal">keyStorePassword</code> through
    <code class="literal">javax.net.ssl.keyStore</code> and <code class="literal">javax.net.ssl.keyStorePassword</code> system properties.

    <span class="italic">Note that, you can not use SSL when <a class="link" href="#Encryption" title="12.2.6.&nbsp;Encryption">Hazelcast Encryption</a> is enabled.</span>
    </p></div><div class="sect2" title="12.2.6.&nbsp;Encryption"><div class="titlepage"><div><div><h3 class="title"><a name="Encryption"></a>12.2.6.&nbsp;Encryption</h3></div></div></div><p>
    Hazelcast allows you to encrypt entire socket level communication among all Hazelcast
    members. Encryption is based on
    <a class="link" href="http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html" target="_top">Java
        Cryptography Architecture
    </a>
    and both symmetric and asymmetric encryption are supported.
    In symmetric encryption, each node uses the same key, so the key is shared.
    Here is a sample configuration for symmetric encryption:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <em class="hl-comment" style="color: silver">&lt;!--
            Make sure to set enabled=true
            Make sure this configuration is exactly the same on
            all members
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;symmetric-encryption</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               encryption algorithm such as
               DES/ECB/PKCS5Padding,
               PBEWithMD5AndDES,
               Blowfish,
               DESede
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;algorithm&gt;</font>PBEWithMD5AndDES<font font-style="bold" color="#0A1777">&lt;/algorithm&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- salt value to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;salt&gt;</font>thesalt<font font-style="bold" color="#0A1777">&lt;/salt&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- pass phrase to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;password&gt;</font>thepass<font font-style="bold" color="#0A1777">&lt;/password&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- iteration count to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;iteration-count&gt;</font>19<font font-style="bold" color="#0A1777">&lt;/iteration-count&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/symmetric-encryption&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    In asymmetric encryption, public and private key pair is used. Data is encrypted with
    one of these keys and decrypted with the other.
    The idea is that each node has to have its own private key and other trusted members'
    public key. So that means, for each member, we should do the followings:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Pick a unique name for the member. We will use the name as the key alias. Let's name them as member1,
                member2...memberN.
            </p></li><li class="listitem"><p>Generate the keystore and the private key for the member1.
                <code class="literal">keytool -genkey -alias member1 -keyalg RSA -keypass thekeypass -keystore keystore -storetype
                    JKS
                </code>
                Remember all the parameters you used here because you will need this information when
                you configure asymmetric-encryption in your hazelcast.xml file.
            </p></li><li class="listitem"><p>Create a public certificate file so that we can add it to the other members' keystore
                <code class="literal">keytool -export -alias member1 -keypass thekeypass -storepass thestorepass -keystore keystore
                    -rfc -file member1.cer
                </code>
            </p></li><li class="listitem"><p>Now take all the other members' public certificates, and add (import) them into member1's keystore
                </p><pre class="programlisting"> keytool -<strong class="hl-keyword">import</strong> -alias member2 -file member2.cer -keystore keystore -storepass thestorepass

 keytool -<strong class="hl-keyword">import</strong> -alias member3 -file member3.cer -keystore keystore -storepass thestorepass

 ...

 keytool -<strong class="hl-keyword">import</strong> -alias memberN -file memberN.cer -keystore keystore -storepass thestorepass

</pre><p>
            </p></li></ul></div><p>
    You should repeat these steps for each trusted member in your cluster.
    Here is a sample configuration for asymmetric encryption:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <em class="hl-comment" style="color: silver">&lt;!--
            Make sure to set enabled=true
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;asymmetric-encryption</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- encryption algorithm --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;algorithm&gt;</font>RSA/NONE/PKCS1PADDING<font font-style="bold" color="#0A1777">&lt;/algorithm&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- private key password --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;keyPassword&gt;</font>thekeypass<font font-style="bold" color="#0A1777">&lt;/keyPassword&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- private key alias --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;keyAlias&gt;</font>member1<font font-style="bold" color="#0A1777">&lt;/keyAlias&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- key store type --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;storeType&gt;</font>JKS<font font-style="bold" color="#0A1777">&lt;/storeType&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- key store password --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;storePassword&gt;</font>thestorepass<font font-style="bold" color="#0A1777">&lt;/storePassword&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- path to the key store --&gt;</em> 
            <font font-style="bold" color="#0A1777">&lt;storePath&gt;</font>keystore<font font-style="bold" color="#0A1777">&lt;/storePath&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/asymmetric-encryption&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

</p></div><div class="sect2" title="12.2.7.&nbsp;Socket Interceptor"><div class="titlepage"><div><div><h3 class="title"><a name="SocketInterceptor"></a>12.2.7.&nbsp;Socket Interceptor</h3></div></div></div><p>
    Hazelcast allows you to intercept socket connections before a node joins to cluster or a client connects to a node.
    This provides ability to add custom hooks to join/connection procedure (like identity checking using Kerberos, etc.).
    You should implement <code class="code">com.hazelcast.nio.MemberSocketInterceptor</code> for members and
    <code class="code">com.hazelcast.nio.SocketInterceptor</code> for clients.

    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySocketInterceptor <strong class="hl-keyword">implements</strong> MemberSocketInterceptor {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init(SocketInterceptorConfig socketInterceptorConfig) {
        <em class="hl-comment" style="color: silver">// initialize interceptor</em>
    }

    <strong class="hl-keyword">void</strong> onConnect(Socket connectedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when connected</em>
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onAccept(Socket acceptedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when accepted a connection</em>
    }
}
</pre><p>

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
       <font font-style="bold" color="#0A1777">&lt;socket-interceptor</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.examples.MySocketInterceptor<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kerberos-host"</font><font font-style="bold" color="#0A1777">&gt;</font>kerb-host-name<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kerberos-config-file"</font><font font-style="bold" color="#0A1777">&gt;</font>kerb.conf<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
       <font font-style="bold" color="#0A1777">&lt;/socket-interceptor&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>


</p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyClientSocketInterceptor <strong class="hl-keyword">implements</strong> SocketInterceptor {
    <strong class="hl-keyword">void</strong> onConnect(Socket connectedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when connected</em>
    }
}

ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
clientConfig.setGroupConfig(<strong class="hl-keyword">new</strong> GroupConfig(<font font-style="normal" color="#008000">"dev"</font>,<font font-style="normal" color="#008000">"dev-pass"</font>)).addAddress(<font font-style="normal" color="#008000">"10.10.3.4"</font>);

MyClientSocketInterceptor myClientSocketInterceptor = <strong class="hl-keyword">new</strong> MyClientSocketInterceptor();
clientConfig.setSocketInterceptor(myClientSocketInterceptor);
HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
</pre><p>

</p></div><div class="sect2" title="12.2.8.&nbsp;IPv6 Support"><div class="titlepage"><div><div><h3 class="title"><a name="IPv6"></a>12.2.8.&nbsp;IPv6 Support</h3></div></div></div><p>
    Hazelcast supports IPv6 addresses seamlessly. [<span class="emphasis"><em>IPv6 support has been switched off by default.
        <a class="link" href="#IPv6-Note">See note below</a></em></span>]
        All you need is to define IPv6 addresses or interfaces in
    <a class="link" href="#NetworkConfig" title="12.2.&nbsp;Network Configuration">network configuration</a>. Only limitation at the moment is you can not define
    wildcard IPv6 addresses in <a class="link" href="#ConfigTcpIp" title="12.2.1.&nbsp;Configuring TCP/IP Cluster">TCP-IP</a> join configuration.
    <a class="link" href="#ConfigSpecifyInterfaces" title="12.2.2.&nbsp;Specifying Network Interfaces">Interfaces</a> section does not have this limitation, you can
    configure wildcard IPv6 interfaces same as IPv4 interfaces.

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>FF02:0:0:0:0:0:0:1<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>[fe80::223:6cff:fe93:7c7e]:5701<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.0-7<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80:0:0:0:45c5:47ee:fe15:493a<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interfaces</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.16.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.10.4-18<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80:0:0:0:45c5:47ee:fe15:*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80::223:6cff:fe93:0-5555<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/interfaces&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
</pre><p>
</p><p>
        JVM has two system properties for setting the preferred protocol stack &#8212;IPv4 or IPv6&#8212; as well as the preferred
        address family types &#8212;inet4 or inet6. On a dual stack machine IPv6 stack is preferred by default, this can be
        changed through <code class="code">java.net.preferIPv4Stack=&lt;true|false&gt;</code> system property. And when querying name
        services JVM prefers IPv4 addressed over IPv6 addresses and will return an IPv4 address if possible. This can be
        changed through <code class="code">java.net.preferIPv6Addresses=&lt;true|false&gt;</code> system property.
    </p><p>
    Also see additional <a class="link" href="http://docs.oracle.com/javase/1.5.0/docs/guide/net/ipv6_guide/index.html#details" target="_top">
        details on IPv6 support in Java
    </a>.
    </p><p><a name="IPv6-Note"></a>
    <span class="bold"><strong>Note:</strong></span>
    </p><p>
        IPv6 support has been switched off by default, since some platforms have issues in use of IPv6 stack. And some other
        platforms such as Amazon AWS have no support at all. To enable IPv6 support, just set configuration property
        <code class="code">hazelcast.prefer.ipv4.stack</code> to false.
        See <a class="link" href="#ConfigurationProperties" title="12.6.&nbsp;Advanced Configuration Properties">Configuration Properties.</a>
    </p></div><div class="sect2" title="12.2.9.&nbsp;Restricting Outbound Ports"><div class="titlepage"><div><div><h3 class="title"><a name="OutboundPorts"></a>12.2.9.&nbsp;Restricting Outbound Ports</h3></div></div></div><p>
    By default Hazelcast lets the system to pick up an ephemeral port during socket bind operation.
    But security policies/firewalls may require to restrict outbound ports to be used by Hazelcast enabled applications.
    To fulfill this requirement, you can configure Hazelcast to use only defined outbound ports.

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;outbound-ports&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>33000-35000<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font>   <em class="hl-comment" style="color: silver">&lt;!-- ports between 33000 and 35000 --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>37000,37001,37002,37003<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font> <em class="hl-comment" style="color: silver">&lt;!-- comma separated ports --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>38000,38500-38600<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/outbound-ports&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>


    </p><pre class="programlisting">
    ...

    NetworkConfig networkConfig = config.getNetworkConfig();
    networkConfig.addOutboundPortDefinition(<font font-style="normal" color="#008000">"35000-35100"</font>);         <em class="hl-comment" style="color: silver">// ports between 35000 and 35100</em>
    networkConfig.addOutboundPortDefinition(<font font-style="normal" color="#008000">"36001, 36002, 36003"</font>); <em class="hl-comment" style="color: silver">// comma separated ports</em>
    networkConfig.addOutboundPort(<span class="hl-number">37000</span>);
    networkConfig.addOutboundPort(<span class="hl-number">37001</span>);
    ...
</pre><p>

    <span class="italic">* You can use port ranges and/or comma separated ports.</span>
    </p></div></div><div class="sect1" title="12.3.&nbsp;Partition Group Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PartitionGroupConfig"></a>12.3.&nbsp;Partition Group Configuration</h2></div></div></div><p>Hazelcast distributes key objects into partitions (blocks) using a consistent hashing algorithm and those partitions are assigned to nodes. That means an entry is stored in a node which is owner of partition to that entry's key is assigned. Number of total partitions is default 271 and can be changed with configuration property <code class="code">hazelcast.map.partition.count</code>. Along with those partitions, there are also copies of them as backups. Backup partitions can have multiple copies due to backup count defined in configuration, such as first backup partition, second backup partition etc. As a rule, a node can not hold more than one copy of a partition (ownership or backup). By default Hazelcast distributes partitions and their backup copies randomly and equally among cluster nodes assuming all nodes in the cluster are identical.
    </p><p>
        <span class="italic">What if some nodes share same JVM or physical machine or chassis and you want backups of these nodes to be assigned to nodes in another machine or chassis? What if processing or memory capacities of some nodes are different and you do not want equal number of partitions to be assigned to all nodes?
        </span>
    </p><p>
        You can group nodes in same JVM (or physical machine) or nodes located in the same chassis. Or you can group nodes to create identical capacity. We call these groups as <code class="literal">partition groups</code>. This way partitions are assigned to those partition groups instead of single nodes. And backups of these partitions are located in another partition group.
    </p><p>When you enable partition grouping, Hazelcast presents two choices to configure partition groups at the moments.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                First one is to group nodes automatically using IP addresses of nodes, so nodes sharing same network interface will be grouped together.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;partition-group</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">group-type</font>=<font font-style="bold" color="#008000">"HOST_AWARE"</font><font font-style="bold" color="#0A1777"> /&gt;</font></pre><p>
                    </p><pre class="programlisting">
Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.HOST_AWARE);</pre><p>
                </p></li><li class="listitem"><p>
                Second one is custom grouping using Hazelcast's interface matching configuration. This way, you can add different and multiple interfaces to a group. You can also use wildcards in interface addresses.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;partition-group</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">group-type</font>=<font font-style="bold" color="#008000">"CUSTOM"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.0.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.3.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.5.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-group&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.10.10-100<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.1.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.2.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-group
&lt;/partition-group&gt;</font></pre><p>
                    </p><pre class="programlisting">
Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.CUSTOM);

MemberGroupConfig memberGroupConfig = <strong class="hl-keyword">new</strong> MemberGroupConfig();
memberGroupConfig.addInterface(<font font-style="normal" color="#008000">"10.10.0.*"</font>)
    .addInterface(<font font-style="normal" color="#008000">"10.10.3.*"</font>).addInterface(<font font-style="normal" color="#008000">"10.10.5.*"</font>);

MemberGroupConfig memberGroupConfig2 = <strong class="hl-keyword">new</strong> MemberGroupConfig();
memberGroupConfig2.addInterface(<font font-style="normal" color="#008000">"10.10.10.10-100"</font>)
    .addInterface(<font font-style="normal" color="#008000">"10.10.1.*"</font>).addInterface(<font font-style="normal" color="#008000">"10.10.2.*"</font>);

partitionGroupConfig.addMemberGroupConfig(memberGroupConfig);
partitionGroupConfig.addMemberGroupConfig(memberGroupConfig2);</pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect1" title="12.4.&nbsp;Listener Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ListenerConfig"></a>12.4.&nbsp;Listener Configurations</h2></div></div></div><p>
        Hazelcast provides various event listener extensions to receive specific event types. These are
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>MembershipListener</strong></span> for cluster membership events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>InstanceListener</strong></span> for distributed instance creation and destroy events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MigrationListener</strong></span> for partition migration start and complete events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>LifecycleListener</strong></span> for HazelcastInstance lifecycle events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for IMap and MultiMap entry events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>ItemListener</strong></span> for IQueue, ISet and IList item events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MessageListener</strong></span> for ITopic message events
                </p></li></ul></div><p>
        These listeners can be added to and removed from related object using Hazelcast API. Such as
        </p><pre class="programlisting">MembershipListener listener = <strong class="hl-keyword">new</strong> MyMembershipListener();
hazelcastInstance.getCluster().addMembershipListener(listener);
hazelcastInstance.getCluster().removeMembershipListener(listener);</pre><p>
        </p><pre class="programlisting">EntryListener listener = <strong class="hl-keyword">new</strong> MyEntryListener();
IMap map = hazelcastInstance.getMap(<font font-style="normal" color="#008000">"default"</font>);
map.addEntryListener(listener, true);
map.removeEntryListener(listener);</pre><p>
        </p><pre class="programlisting">ItemListener listener = <strong class="hl-keyword">new</strong> MyItemListener();
IQueue queue = hazelcastInstance.getQueue(<font font-style="normal" color="#008000">"default"</font>);
queue.addItemListener(listener, true);
queue.removeItemListener(listener);</pre><p>
    </p><p>
        Downside of attaching listeners using API is possibility of missing events between creation of object and registering listener. To overcome this race condition Hazelcast introduces registration of listeners in configuration. Listeners can be registered using either Hazelcast XML configuration, Config API or Spring configuration.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>MembershipListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.MembershipListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MembershipListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMembershipListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMembershipListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>InstanceListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.InstanceListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.InstanceListener"</font>));</pre><p>
                </p><p>
                <span class="italic">Spring XML configuration</span>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyInstanceListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyInstanceListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MigrationListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.MigrationListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MigrationListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMigrationListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMigrationListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>LifecycleListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.LifecycleListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
                        config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.LifecycleListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyLifecycleListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyLifecycleListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for IMap
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;entry-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.EntryListener<font font-style="bold" color="#0A1777">&lt;/entry-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
mapConfig.addEntryListenerConfig(<strong class="hl-keyword">new</strong> EntryListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.EntryListener"</font>, false, false));</pre><p>
                </p><p>
                <span class="italic">Spring XML configuration</span>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyEntryListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyEntryListener"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for MultiMap
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;multimap</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;value-collection-type&gt;</font>SET<font font-style="bold" color="#0A1777">&lt;/value-collection-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;entry-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.EntryListener<font font-style="bold" color="#0A1777">&lt;/entry-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/multimap&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
multiMapConfig.addEntryListenerConfig(<strong class="hl-keyword">new</strong> EntryListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.EntryListener"</font>, false, false));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:multimap</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font> <font font-style="bold" color="#0A1777">value-collection-type</font>=<font font-style="bold" color="#008000">"LIST"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyEntryListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyEntryListener"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:multimap&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>ItemListener</strong></span> for IQueue
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;item-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;item-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.ItemListener<font font-style="bold" color="#0A1777">&lt;/item-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/item-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
queueConfig.addItemListenerConfig(<strong class="hl-keyword">new</strong> ItemListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.ItemListener"</font>, true));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font> <font font-style="bold" color="#0A1777">max-size-per-jvm</font>=<font font-style="bold" color="#008000">"1000"</font> <font font-style="bold" color="#0A1777">backing-map-ref</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:item-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:item-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyItemListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:item-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:queue&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MessageListener</strong></span> for ITopic
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;topic</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;message-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;message-listener&gt;</font>com.hazelcast.examples.MessageListener<font font-style="bold" color="#0A1777">&lt;/message-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/message-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/topic&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
topicConfig.addMessageListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MessageListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:topic</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:message-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:message-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMessageListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:message-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:topic&gt;</font></pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect1" title="12.5.&nbsp;Wildcard Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="WildcardConfiguration"></a>12.5.&nbsp;Wildcard Configuration</h2></div></div></div><p>Hazelcast supports wildcard configuration of Maps, Queues and Topics. Using an asterisk
        (*) character in the name, different instances of Maps, Queues and Topics can be configured
        by a single configuration.
    </p><p>Note that, with a limitation of a single usage, asterisk (*) can be placed anywhere
        inside the configuration name.
    </p><p>For instance a map named '<code class="code">com.hazelcast.test.mymap</code>' can be configured using one of
        these configurations;
    </p><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazelcast.test.*"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazel*"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*.test.mymap"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.*test.mymap"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>

        Or a queue '<code class="code">com.hazelcast.test.myqueue</code>'
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*hazelcast.test.myqueue"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazelcast.*.myqueue"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
    </p></div><div class="sect1" title="12.6.&nbsp;Advanced Configuration Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigurationProperties"></a>12.6.&nbsp;Advanced Configuration Properties</h2></div></div></div><p>
        There are some advanced configuration properties to tune some aspects
        of Hazelcast. These can be set as property name and value pairs
        through configuration xml, configuration API or JVM system property.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>Configuration xml</strong></span>
                </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-2.3.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ....
    <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hazelcast.property.foo"</font><font font-style="bold" color="#0A1777">&gt;</font>value<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            ....
    <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>Configuration API</strong></span>
                </p><p>
                    </p><pre class="programlisting">
Config cfg = <strong class="hl-keyword">new</strong> Config() ;
cfg.setProperty(<font font-style="normal" color="#008000">"hazelcast.property.foo"</font>, <font font-style="normal" color="#008000">"value"</font>);
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>System Property</strong></span>
                </p><p>
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using JVM parameter:
                                <code class="literal">java -Dhazelcast.property.foo=value</code>
                            </p></li><li class="listitem"><p>Using System class:
                                <code class="literal">System.setProperty("hazelcast.property.foo", "value");
                                </code>
                            </p></li></ol></div><p>
                </p></li></ul></div><p>
    </p><table border="1" width="950" id="d0e3447"><caption>Table&nbsp;12.1.&nbsp;Properties Table</caption><col width="44%"><col width="36%"><col width="10%"><col width="6%"><col width="2%"><col width="2%"><col width="2%"><thead><tr>
                <th>Property Name</th>
                <th>Description</th>
                <th>Value Type</th>
                <th>Default</th>
            </tr></thead><tbody><tr>
                <td>
                    <code class="literal"><a name="hazelcast.memcache.enabled"></a>hazelcast.memcache.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#MemcacheClient" title="15.2.&nbsp;Memcache Client">Memcache</a>
                    client request listener service
                </td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.rest.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#RestClient" title="15.3.&nbsp;Rest Client">REST</a>
                    client request listener service
                </td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.logging.type</code>
                </td>
                <td>Name of
                    <a class="link" href="#Logging" title="12.7.&nbsp;Logging Configuration">logging</a>
                    framework type to send logging events.
                </td>
                <td>enum</td>
                <td>jdk</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.load.chunk.size</code>
                </td>
                <td>Chunk size for
                    <a class="link" href="#MapPersistence" title="2.3.3.&nbsp;Persistence">MapLoader</a>
                    's map initialization
                    process (MapLoder.loadAllKeys())
                </td>
                <td>integer</td>
                <td>1000</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.in.thread.priority</code>
                </td>
                <td>Hazelcast
                    Input Thread
                    priority
                </td>
                <td>integer</td>
                <td>7</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.out.thread.priority</code>
                </td>
                <td>Hazelcast
                    Output Thread
                    priority
                </td>
                <td>integer</td>
                <td>7</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.service.thread.priority</code>
                </td>
                <td>Hazelcast
                    Service Thread
                    priority
                </td>
                <td>integer</td>
                <td>8</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.merge.first.run.delay.seconds</code>
                </td>
                <td>Inital run delay of
                    <a class="link" href="#NetworkPartitioning" title="12.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)">split brain/merge process</a>
                    in seconds
                </td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.merge.next.run.delay.seconds</code>
                </td>
                <td>Run interval of
                    <a class="link" href="#NetworkPartitioning" title="12.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)">split brain/merge process</a>
                    in
                    seconds
                </td>
                <td>integer</td>
                <td>120</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.redo.wait.millis"></a>hazelcast.redo.wait.millis</code>
                </td>
                <td>Wait time before a redo operation in milliseconds</td>
                <td>integer</td>
                <td>500</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.redo.log.threshold"></a>hazelcast.redo.log.threshold</code>
                </td>
                <td>Minimum number of redo(s) before logging.</td>
                <td>integer</td>
                <td>10</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.redo.giveup.threshold"></a>hazelcast.redo.giveup.threshold</code>
                </td>
                <td>Number of maximum redo calls before giving up and throwing <code class="code">OperationTimeoutException</code>.</td>
                <td>integer</td>
                <td>60</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.backup.redo.enabled"></a>hazelcast.backup.redo.enabled</code>
                </td>
                <td>Enable (strict) redo for backup operations. Backup operations may fail due to node failures,
                    but generally during partition re-assignment process missing backups are restored.
                    <span class="emphasis"><em>When 'hazelcast.backup.redo.enabled' is set to true,
                        <a class="link" href="#hazelcast.partition.migration.interval">#hazelcast.partition.migration.interval</a> should be 0.</em></span>
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.max.operation.timeout"></a>hazelcast.max.operation.timeout</code>
                </td>
                <td>Maximum operation timeout in milliseconds if no timeout is specified for an operation. (default 300 seconds)</td>
                <td>integer</td>
                <td>300000</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.max.concurrent.operation.limit"></a>hazelcast.max.concurrent.operation.limit</code>
                </td>
                <td>Max number of concurrent operations can be submitted to Hazelcast without throwing
                    <code class="code">OperationRejectedException</code> (negative means undefined).</td>
                <td>integer</td>
                <td>-1</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.bind.any</code>
                </td>
                <td>Bind node socket address to any local address</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.receive.buffer.size</code>
                </td>
                <td>Socket receive buffer size in KB</td>
                <td>integer</td>
                <td>32</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.send.buffer.size</code>
                </td>
                <td>Socket send buffer size in KB</td>
                <td>integer</td>
                <td>32</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.keep.alive</code>
                </td>
                <td>Socket set keep alive</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.no.delay</code>
                </td>
                <td>Socket set TCP no delay</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.prefer.ipv4.stack</code>
                </td>
                <td>Prefer Ipv4 network interface when picking a local address.</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.shutdownhook.enabled</code>
                </td>
                <td>Enable Hazelcast shutdownhook thread</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.wait.seconds.before.join</code>
                </td>
                <td>Wait time before join operation</td>
                <td>integer</td>
                <td>5</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.wait.seconds.before.join</code>
                </td>
                <td>Maximum wait time before join operation</td>
                <td>integer</td>
                <td>20</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.heartbeat.interval.seconds</code>
                </td>
                <td>Heartbeat send interval in seconds</td>
                <td>integer</td>
                <td>1</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.no.heartbeat.seconds</code>
                </td>
                <td>Max timeout of heartbeat in seconds for a node to assume it is dead</td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.enabled</code>
                </td>
                <td>Enable ICMP ping</td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.timeout</code>
                </td>
                <td>ICMP timeout in ms</td>
                <td>int</td>
                <td>1000</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.ttl</code>
                </td>
                <td>ICMP TTL (maximum numbers of hops to try)</td>
                <td>int</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.master.confirmation.interval.seconds</code>
                </td>
                <td>Interval at which nodes send master confirmation</td>
                <td>integer</td>
                <td>30</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.no.master.confirmation.seconds</code>
                </td>
                <td>Max timeout of master confirmation from other nodes</td>
                <td>integer</td>
                <td>450</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.member.list.publish.interval.seconds</code>
                </td>
                <td>Interval at which master node publishes a member list</td>
                <td>integer</td>
                <td>600</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.prefer.ipv4.stack</code>
                </td>
                <td>Prefer IPv4 Stack, don't use IPv6. See <a class="link" href="#IPv6" title="12.2.8.&nbsp;IPv6 Support">IPv6 doc.</a></td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.initial.min.cluster.size</code>
                </td>
                <td>Initial expected cluster size to wait before node to start completely</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.initial.wait.seconds</code>
                </td>
                <td>Inital time in seconds to wait before node to start completely</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.restart.on.max.idle</code>
                </td>
                <td>Restart node if service thread blocked for
                    <code class="literal">hazelcast.max.no.heartbeat.seconds</code>
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.partition.count</code>
                </td>
                <td>Distributed map partition count</td>
                <td>integer</td>
                <td>271</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.max.backup.count</code>
                </td>
                <td>Maximum map backup node count</td>
                <td>integer</td>
                <td>5</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.remove.delay.seconds</code>
                </td>
                <td>Remove delay time in seconds for dirty records</td>
                <td>integer</td>
                <td>5</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.cleanup.delay.seconds</code>
                </td>
                <td>Cleanup process delay time in seconds</td>
                <td>integer</td>
                <td>10</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.executor.query.thread.count</code>
                </td>
                <td>Query executor service max thread count</td>
                <td>integer</td>
                <td>8</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.executor.event.thread.count</code>
                </td>
                <td>Event executor service max thread count</td>
                <td>integer</td>
                <td>16</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.executor.client.thread.count</code>
                </td>
                <td>Client executor service max thread count</td>
                <td>integer</td>
                <td>40</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.executor.store.thread.count</code>
                </td>
                <td>Map store executor service max thread count</td>
                <td>integer</td>
                <td>16</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.log.state</code>
                </td>
                <td>Log cluster debug state periodically</td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.jmx</code>
                </td>
                <td>Enable
                    <a class="link" href="#JMX" title="Chapter&nbsp;6.&nbsp;Monitoring with JMX">JMX</a>
                    agent
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.jmx.detailed</code>
                </td>
                <td>Enable detailed views on
                    <a class="link" href="#JMX" title="Chapter&nbsp;6.&nbsp;Monitoring with JMX">JMX</a>
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.map.excludes</code>
                </td>
                <td>Comma seperated map names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.queue.excludes</code>
                </td>
                <td>Comma seperated queue names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.topic.excludes</code>
                </td>
                <td>Comma seperated topic names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.version.check.enabled</code>
                </td>
                <td>Enable Hazelcast new version check on startup</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.topic.flow.control.enabled</code>
                </td>
                <td>Enable waiting for the topic publish until messages are written through the sockets</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.max.visible.instance.count</code>
                </td>
                <td>Management Center maximum visible instance count</td>
                <td>integer</td>
                <td>100</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.connection.monitor.interval</code>
                </td>
                <td>Minimum interval to consider a connection error as critical in milliseconds.</td>
                <td>integer</td>
                <td>100</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.connection.monitor.max.faults</code>
                </td>
                <td>Maximum IO error count before disconnecting from a node.</td>
                <td>integer</td>
                <td>3</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.partition.migration.interval"></a>hazelcast.partition.migration.interval</code>
                </td>
                <td>Interval to run partition migration tasks in seconds.</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.partition.migration.timeout</code>
                </td>
                <td>Timeout for partition migration tasks in seconds.</td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.immediate.backup.interval</code>
                </td>
                <td>Interval to run immediate backup tasks in seconds.</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.graceful.shutdown.max.wait</code>
                </td>
                <td>Maximum wait seconds during graceful shutdown.</td>
                <td>integer</td>
                <td>600</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.force.throw.interrupted.exception</code>
                </td>
                <td>Force throw of RuntimeInterruptedException when a thread is interrupted, otherwise a
                    warning log will be printed.</td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.url.change.enabled</code>
                </td>
                <td>Management Center changing server url is enabled</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;3.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    off-heap storage
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.total.size</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;3.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    storage total size in MB
                </td>
                <td>integer</td>
                <td>128</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.chunk.size</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;3.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    storage chunk size in KB
                </td>
                <td>integer</td>
                <td>1</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.shared.storage</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;3.&nbsp;Elastic Memory (Enterprise Edition Only)">Enable Hazelcast Elastic Memory</a>
                    shared storage
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.enterprise.license.key</code>
                </td>
                <td>
                    <a class="link" href="http://www.hazelcast.com/products.jsp" target="_top">Hazelcast Enterprise</a>
                    license key
                </td>
                <td>string</td>
                <td>null</td>
            </tr></tbody></table></div><div class="sect1" title="12.7.&nbsp;Logging Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Logging"></a>12.7.&nbsp;Logging Configuration</h2></div></div></div><p>Hazelcast has a flexible logging configuration and doesn't depend on any logging framework except JDK logging.
        It has in-built adaptors for a number of logging frameworks
        and also supports custom loggers by providing logging interfaces.
    </p><p>To use built-in adaptors you should set
        <code class="code">hazelcast.logging.type</code>
        property to one of
        predefined types below.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>jdk:</strong></span>JDK logging (default)
                </p></li><li class="listitem"><p><span class="bold"><strong>log4j:</strong></span>Log4j
                </p></li><li class="listitem"><p><span class="bold"><strong>slf4j:</strong></span>Slf4j
                </p></li><li class="listitem"><p><span class="bold"><strong>none:</strong></span>disable logging
                </p></li></ul></div><p>

        You can set
        <code class="code">hazelcast.logging.type</code>
        through configuration xml, configuration API or JVM system property.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>Configuration xml</strong></span>
                </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-2.3.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>

    ....

    <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hazelcast.logging.type"</font><font font-style="bold" color="#0A1777">&gt;</font>jdk<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        ....
    <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>Configuration API</strong></span>
                </p><p>
                    </p><pre class="programlisting">
Config cfg = <strong class="hl-keyword">new</strong> Config() ;
cfg.setProperty(<font font-style="normal" color="#008000">"hazelcast.logging.type"</font>, <font font-style="normal" color="#008000">"log4j"</font>);
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>System Property</strong></span>
                </p><p>
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using JVM parameter:
                                <code class="literal">java -Dhazelcast.logging.type=slf4j</code>
                            </p></li><li class="listitem"><p>Using System class:
                                <code class="literal">System.setProperty("hazelcast.logging.type", "none");</code>
                            </p></li></ol></div><p>
                </p></li></ul></div><p>
    </p><p>To use custom logging feature you should implement
        <code class="code">com.hazelcast.logging.LoggerFactory</code>
        and
        <code class="code">com.hazelcast.logging.ILogger</code>
        interfaces and set system property
        <code class="literal">hazelcast.logging.class</code>
        to
        your custom
        <code class="code">LoggerFactory</code>
        class name.
        </p><pre class="programlisting">java -Dhazelcast.logging.<strong class="hl-keyword">class</strong>=foo.bar.MyLoggingFactory</pre><p>
    </p><p>
        You can also listen logging events generated by Hazelcast runtime by registering<code class="literal">LogListener</code>s
        to<code class="literal">LoggingService</code>.
        </p><pre class="programlisting">
LogListener listener = <strong class="hl-keyword">new</strong> LogListener() {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> log(LogEvent logEvent) {
        <em class="hl-comment" style="color: silver">// do something</em>
    }
}
LoggingService loggingService = Hazelcast.getLoggingService();
loggingService.addLogListener(Level.INFO, listener):
        </pre><p>
        Through the
        <code class="literal">LoggingService</code>
        you can get the current used ILogger implementation and log your own messages too.
    </p></div><div class="sect1" title="12.8.&nbsp;Setting License Key (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="EnterpriseConfig"></a>12.8.&nbsp;Setting License Key <sup>(Enterprise Edition Only)</sup></h2></div></div></div><p>To be able to use Hazelcast Enterprise Edition, you need to set license key in configuration.</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>Hazelcast XML Configuration</strong></span> </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;license-key&gt;</font>HAZELCAST_ENTERPRISE_LICENSE_KEY<font font-style="bold" color="#0A1777">&lt;/license-key&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>Hazelcast Config API</strong></span> </p><p>
                    </p><pre class="programlisting">
Config config = <strong class="hl-keyword">new</strong> Config();
config.setLicenseKey(<font font-style="normal" color="#008000">"HAZELCAST_ENTERPRISE_LICENSE_KEY"</font>);
</pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>Spring XML Configuration</strong></span> </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;hz:license-key&gt;</font>HAZELCAST_ENTERPRISE_LICENSE_KEY<font font-style="bold" color="#0A1777">&lt;/hz:license-key&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>JVM System Property</strong></span> </p><p>
                    </p><pre class="programlisting">-Dhazelcast.enterprise.license.key=HAZELCAST_ENTERPRISE_LICENSE_KEY</pre><p>
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Hibernate Second Level Cache"><div class="titlepage"><div><div><h2 class="title"><a name="HibernateSecondLevelCache"></a>Chapter&nbsp;13.&nbsp;Hibernate Second Level Cache</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    Hazelcast provides distributed second level cache for
    your Hibernate entities, collections and queries. Hazelcast has two implementations of Hibernate
    2nd level cache, one for hibernate-pre-3.3 and one for hibernate-3.3.x versions. In your
    Hibernate configuration file (ex: hibernate.cfg.xml), add these properties;
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>To enable use of second level cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_second_level_cache"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>To enable use of query cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_query_cache"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>And to force minimal puts into cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_minimal_puts"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>To configure Hazelcast for Hibernate, it is enough to put configuration file named
                <code class="literal">hazelcast.xml</code>
                into root of your classpath. If Hazelcast can
                not find
                <code class="literal">hazelcast.xml</code>
                then it will use default configuration
                from hazelcast.jar.
            </p></li><li class="listitem"><p>You can define custom named Hazelcast configuration xml file with one of these
                Hibernate configuration properties.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.provider_configuration_file_resource_path"</font><font font-style="bold" color="#0A1777">&gt;</font>hazelcast-custom-config.xml<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
                or
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.configuration_file_path"</font><font font-style="bold" color="#0A1777">&gt;</font>hazelcast-custom-config.xml<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>You can set up Hazelcast to connect cluster as LiteMember. LiteMember is a
                member of the cluster, it has socket connection to every member in the cluster and
                it knows where the data, but does not contain any data.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.use_lite_member"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>You can set up Hazelcast to connect cluster as Native Client. Native client is not
                member and it connects to one of the cluster members and delegates all cluster wide
                operations to it. When the relied cluster member dies, client will transparently
                switch to another live member. <span class="italic">(Native Client property takes precedence
                    over LiteMember property.)</span>
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.use_native_client"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
                To setup Native Client properly, you should add Hazelcast<span class="bold"><strong>group-name</strong></span>,
                <span class="bold"><strong>group-password</strong></span>
                and
                <span class="bold"><strong>cluster member address</strong></span>
                properties. Native Client
                will connect to defined member and will get addresses of all members in the cluster.
                If the connected member will die or leave the cluster, client will automatically
                switch to another member in the cluster.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_address"</font><font font-style="bold" color="#0A1777">&gt;</font>10.34.22.15<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_group"</font><font font-style="bold" color="#0A1777">&gt;</font>dev<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_password"</font><font font-style="bold" color="#0A1777">&gt;</font>dev-pass<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
                <span class="italic">To use Native Client you should add
                    <code class="literal">hazelcast-client-&lt;version&gt;.jar</code>
                    into your
                    classpath.
                </span>
            </p><p>
                <a class="link" href="#NativeClient" title="15.1.&nbsp;Native Client">Read more about NativeClient &amp; LiteMember</a>
            </p></li><li class="listitem"><p>If you are using one of Hibernate pre-3.3 version, add following property.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.provider_class"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.hibernate.provider.HazelcastCacheProvider<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>If you are using Hibernate 3.3.x (or newer) version, you can choose to use either
                configuration property above (Hibernate has a built-in bridge to use old-style cache
                implementations) or following property.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.region.factory_class"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.hibernate.HazelcastCacheRegionFactory<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li></ul></div><p>
    Hazelcast creates a seperate distributed map for each Hibernate cache region. So
    these regions can be configured easily via Hazelcast map configuration. You can define<span class="bold"><strong>backup</strong></span>,<span class="bold"><strong>eviction</strong></span>,
    <span class="bold"><strong>TTL
    </strong></span>
    and
    <span class="bold"><strong>Near Cache</strong></span>
    properties.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <a class="link" href="#MapBackup" title="2.3.1.&nbsp;Backups">Backup Configuration</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MapEviction" title="2.3.2.&nbsp;Eviction">Eviction And TTL Configuration</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MapNearCache" title="2.3.5.&nbsp;Near Cache">Near Cache Configuration</a>
            </p></li></ul></div><p>
    Hibernate has four cache concurrency
    strategies:<span class="emphasis"><em>read-only</em></span>,<span class="emphasis"><em>read-write</em></span>,
    <span class="emphasis"><em>nonstrict-read-write</em></span>
    and<span class="emphasis"><em>transactional</em></span>. But
    Hibernate does not forces cache providers to support all strategies. And Hazelcast supports
    first three (<span class="bold"><strong>read-only</strong></span>,<span class="bold"><strong>read-write</strong></span>,<span class="bold"><strong>nonstrict-read-write</strong></span>) of these four
    strategies. Hazelcast has not support for
    <span class="emphasis"><em>transactional</em></span>
    strategy yet.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If you are using xml based class configurations, you should add a
                <span class="emphasis"><em>cache</em></span>
                element into your configuration with
                <span class="emphasis"><em>usage</em></span>
                attribute with one
                of<span class="emphasis"><em>read-only</em></span>,<span class="emphasis"><em>read-write</em></span>,<span class="emphasis"><em>
                    nonstrict-read-write</em></span>.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;class</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"eg.Immutable"</font> <font font-style="bold" color="#0A1777">mutable</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-only"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    .... 
<font font-style="bold" color="#0A1777">&lt;/class&gt;</font>

<font font-style="bold" color="#0A1777">&lt;class</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"eg.Cat"</font> <font font-style="bold" color="#0A1777">....</font><font font-style="bold" color="#0A1777"> &gt;</font>
    <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    ....
    <font font-style="bold" color="#0A1777">&lt;set</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kittens"</font> <font font-style="bold" color="#0A1777">...</font><font font-style="bold" color="#0A1777"> &gt;</font>
        <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        ....
    <font font-style="bold" color="#0A1777">&lt;/set&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/class&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>If you are using Hibernate-Annotations then you can add
                <span class="emphasis"><em>class-cache</em></span>
                or
                <span class="emphasis"><em>collection-cache</em></span>
                element into your Hibernate configuration file with
                <span class="emphasis"><em>usage</em></span>
                attribute with one of<span class="emphasis"><em>read
                    only</em></span>,<span class="emphasis"><em>read/write</em></span>,<span class="emphasis"><em>nonstrict
                    read/write</em></span>.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;class-cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-only"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"eg.Immutable"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;class-cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"eg.Cat"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;collection-cache</font> <font font-style="bold" color="#0A1777">collection</font>=<font font-style="bold" color="#008000">"eg.Cat.kittens"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
</pre><p>
            </p></li></ul></div><p>
    OR
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Alternatively, you can put Hibernate Annotation's
                <span class="emphasis"><em>@Cache</em></span>
                annotation on your entities and collections.
                </p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Cat <strong class="hl-keyword">implements</strong> Serializable {
     ...
}
</pre><p>
            </p></li></ul></div><p>
    And now last thing you should be aware of is to drop
    hazelcast-hibernate-&lt;version&gt;.jar into your classpath.

    </p><div class="itemizedlist" title="Additional Properties:"><p class="title"><b>Additional Properties:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <span class="bold"><strong>Accessing underlying
                    <code class="code">HazelcastInstance</code>
                </strong></span>
            </p><p>Using
                <code class="code">com.hazelcast.hibernate.instance.HazelcastAccessor</code>
                you can access underlying
                <code class="code">HazelcastInstance</code>
                used by Hibernate SessionFactory.
                </p><pre class="programlisting">SessionFactory sessionFactory = ...;
HazelcastInstance hazelcastInstance = HazelcastAccessor.getHazelcastInstance(sessionFactory);        
</pre><p>
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Changing/setting lock timeout value of
                    <span class="italic">read-write</span>
                    strategy
                </strong></span>
            </p><p>Lock timeout value can be set using
                <code class="literal">hibernate.cache.hazelcast.lock_timeout_in_seconds</code>
                Hibernate property.
                Value should be in seconds and default value is 300 seconds.
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Using named
                    <code class="literal">HazelcastInstance</code>
                </strong></span>
            </p><p>Instead of creating a new
                <code class="literal">HazelcastInstance</code>
                for each<code class="literal">SessionFactory</code>,
                an existing instance can be used by setting
                <code class="literal">hibernate.cache.hazelcast.instance_name</code>
                Hibernate
                property to<code class="literal">HazelcastInstance</code>'s name.
                For more information see<a class="link" href="#NamedHazelcastInstance">Named HazelcastInstance</a>.
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Disabling shutdown during SessionFactory.close()</strong></span>
            </p><p>Shutting down
                <code class="literal">HazelcastInstance</code>
                can be disabled during
                <code class="code">SessionFactory.close()</code>
                by setting
                <code class="literal">hibernate.cache.hazelcast.shutdown_on_session_factory_close</code>
                Hibernate property to false.
                <span class="italic">(In this case Hazelcast property
                    <code class="literal">hazelcast.shutdownhook.enabled</code>
                    should not
                    be set to false.)
                </span>
                Default value is<code class="literal">true</code>.
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Spring Integration"><div class="titlepage"><div><div><h2 class="title"><a name="SpringIntegration"></a>Chapter&nbsp;14.&nbsp;Spring Integration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SpringConfiguration">14.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#SpringContext">14.2. Spring Managed Context</a></span></dt><dt><span class="sect1"><a href="#SpringCache">14.3. Spring Cache</a></span></dt><dt><span class="sect1"><a href="#SpringHibernate">14.4. Hibernate 2nd Level Cache Config</a></span></dt><dt><span class="sect1"><a href="#SpringJPA">14.5. Spring Data - JPA</a></span></dt><dt><span class="sect1"><a href="#SpringMongoDB">14.6. Spring Data - MongoDB</a></span></dt></dl></div><div class="sect1" title="14.1.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringConfiguration"></a>14.1.&nbsp;Configuration</h2></div></div></div><p>
    You can declare Hazelcast beans for Spring context
    using <span class="emphasis"><em>beans</em></span> namespace (default spring <span class="emphasis"><em>beans</em></span> namespace)
    as well to declare hazelcast maps, queues and others.
    <span class="bold"><strong>Hazelcast-Spring integration requires either hazelcast-spring jar or hazelcast-all jar in the
        classpath.
    </strong></span>
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.core.Hazelcast"</font> <font font-style="bold" color="#0A1777">factory-method</font>=<font font-style="bold" color="#008000">"newHazelcastInstance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.config.Config"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"groupConfig"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.config.GroupConfig"</font><font font-style="bold" color="#0A1777">&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"password"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"pwd"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- and so on ... --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/constructor-arg&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">factory-bean</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">factory-method</font>=<font font-style="bold" color="#008000">"getMap"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"map"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
    Hazelcast has Spring integration (requires version 2.5 or greater) since 1.9.1
    using
    <span class="emphasis"><em>hazelcast</em></span>
    namespace.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add namespace
                <span class="emphasis"><em>xmlns:hz="http://www.hazelcast.com/schema/spring"</em></span>
                to beans
                tag in context file:
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;beans</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans"</font>
       <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font>
       <font font-style="bold" color="#0A1777">xmlns:hz</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/spring"</font>
       <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring-2.4.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>Use
                <span class="emphasis"><em>hz</em></span>
                namespace shortcuts to declare cluster, its items and
                so on.
            </p></li></ul></div><p>
    After that you can configure Hazelcast instance (node):
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:group</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dev"</font> <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"password"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:network</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"5701"</font> <font font-style="bold" color="#0A1777">port-auto-increment</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:join&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font>
                              <font font-style="bold" color="#0A1777">multicast-group</font>=<font font-style="bold" color="#008000">"224.2.2.3"</font>
                              <font font-style="bold" color="#0A1777">multicast-port</font>=<font font-style="bold" color="#008000">"54327"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:members&gt;</font>10.10.1.2, 10.10.1.3<font font-style="bold" color="#0A1777">&lt;/hz:members&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/hz:tcp-ip&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/hz:join&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/hz:network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map"</font>
                <font font-style="bold" color="#0A1777">backup-count</font>=<font font-style="bold" color="#008000">"2"</font>
                <font font-style="bold" color="#0A1777">max-size</font>=<font font-style="bold" color="#008000">"0"</font>
                <font font-style="bold" color="#0A1777">eviction-percentage</font>=<font font-style="bold" color="#008000">"30"</font>
                <font font-style="bold" color="#0A1777">read-backup-data</font>=<font font-style="bold" color="#008000">"true"</font>
                <font font-style="bold" color="#0A1777">cache-value</font>=<font font-style="bold" color="#008000">"true"</font>
                <font font-style="bold" color="#0A1777">eviction-policy</font>=<font font-style="bold" color="#008000">"NONE"</font>
                <font font-style="bold" color="#0A1777">merge-policy</font>=<font font-style="bold" color="#008000">"hz.ADD_NEW_ENTRY"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>
</pre><p>
    You can easily configure map-store and near-cache too. (For map-store you should set either
    <span class="emphasis"><em>class-name</em></span> or <span class="emphasis"><em>implementation</em></span> attribute.)
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map1"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:near-cache</font> <font font-style="bold" color="#0A1777">time-to-live-seconds</font>=<font font-style="bold" color="#008000">"0"</font> <font font-style="bold" color="#0A1777">max-idle-seconds</font>=<font font-style="bold" color="#008000">"60"</font>
               <font font-style="bold" color="#0A1777">eviction-policy</font>=<font font-style="bold" color="#008000">"LRU"</font> <font font-style="bold" color="#0A1777">max-size</font>=<font font-style="bold" color="#008000">"5000"</font>  <font font-style="bold" color="#0A1777">invalidate-on-change</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>

            <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.foo.DummyStore"</font>
                <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map2"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMapStore"</font>
                <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"dummyMapStore"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.foo.DummyStore"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
</pre><p>
    It's possible to use placeholders instead of concrete values. For instance, use
    property file
    <span class="emphasis"><em>app-default.properties</em></span>
    for group configuration:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"locations"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;list&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;value&gt;</font>classpath:/app-default.properties<font font-style="bold" color="#0A1777">&lt;/value&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/list&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:group</font>
            <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"${cluster.group.name}"</font>
            <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"${cluster.group.password}"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!-- ... --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>
</pre><p>
    Similar for client
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:client</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"client"</font>
    <font font-style="bold" color="#0A1777">group-name</font>=<font font-style="bold" color="#008000">"${cluster.group.name}"</font> <font font-style="bold" color="#0A1777">group-password</font>=<font font-style="bold" color="#008000">"${cluster.group.password}"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:member&gt;</font>10.10.1.2:5701<font font-style="bold" color="#0A1777">&lt;/hz:member&gt;</font>
	<font font-style="bold" color="#0A1777">&lt;hz:member&gt;</font>10.10.1.3:5701<font font-style="bold" color="#0A1777">&lt;/hz:member&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:client&gt;</font>
</pre><p>
    Hazelcast also supports <code class="code">lazy-init</code>, <code class="code">scope</code> and <code class="code">depends-on</code> bean attributes.
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:client</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"prototype"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:client&gt;</font>

</pre><p>
    You can declare beans for the following Hazelcast objects:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>map</p></li><li class="listitem"><p>multiMap</p></li><li class="listitem"><p>queue</p></li><li class="listitem"><p>topic</p></li><li class="listitem"><p>set</p></li><li class="listitem"><p>list</p></li><li class="listitem"><p>executorService</p></li><li class="listitem"><p>idGenerator</p></li><li class="listitem"><p>atomicNumber</p></li><li class="listitem"><p>semaphore</p></li><li class="listitem"><p>countDownLatch</p></li><li class="listitem"><p>lock</p></li></ul></div><p>
    Example:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:multiMap</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"multiMap"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"multiMap"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:queue</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"queue"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"queue"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:topic</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"topic"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"topic"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance, client"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:set</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"set"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"set"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:list</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"list"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"list"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:executorService</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"executorService"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"executorService"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:idGenerator</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"idGenerator"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"idGenerator"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:atomicNumber</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"atomicNumber"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"atomicNumber"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:atomicNumber</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"semaphore"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"semaphore"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:atomicNumber</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"countDownLatch"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"countDownLatch"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:atomicNumber</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"lock"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"lock"</font><font font-style="bold" color="#0A1777">/&gt;</font>
</pre><p>
    </p><a name="SpringInjectingTypedBean"></a><p><a class="link" href="#SpringInjectingTypedBean">
        <span class="bold"><strong>Injecting Typed Collections/Maps</strong></span></a></p><p>
        Spring tries to create a new <code class="code">Map</code>/<code class="code">Collection</code> instance and fill the new instance
        by iterating and converting values of the original <code class="code">Map</code>/<code class="code">Collection</code>
        (<code class="literal">IMap</code>, <code class="literal">IQueue</code> etc.) to required types when generic type parameters
        of the original <code class="code">Map</code>/<code class="code">Collection</code> and the target property/attribute do not match.
    </p><p>
        Since Hazelcast <code class="code">Map</code>s/<code class="code">Collection</code>s are designed to hold very large data
        which a single machine can not carry, iterating through whole values can cause out of memory errors.
    </p><p>
        To avoid this issue either target property/attribute can be declared as
        un-typed <code class="code">Map</code>/<code class="code">Collection</code>
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeBean {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    IMap map; <em class="hl-comment" style="color: silver">// instead of IMap&lt;K, V&gt; map</em>

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    IQueue queue; <em class="hl-comment" style="color: silver">// instead of IQueue&lt;E&gt; queue</em>

    ...
}
</pre><p>

        or parameters of injection methods (constructor, setter) can be un-typed.

        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeBean {

    IMap&lt;K, V&gt; map;

    IQueue&lt;E&gt; queue;

    <strong class="hl-keyword">public</strong> SomeBean(IMap map) { <em class="hl-comment" style="color: silver">// instead of IMap&lt;K, V&gt; map</em>
        <strong class="hl-keyword">this</strong>.map = map;
    }

    ...

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setQueue(IQueue queue) { <em class="hl-comment" style="color: silver">// instead of IQueue&lt;E&gt; queue</em>
        <strong class="hl-keyword">this</strong>.queue = queue;
    }
    ...
}
</pre><p>
        <span class="italic">For more info see
            <a class="link" href="https://jira.springsource.org/browse/SPR-3407" target="_top">
                Spring issue-3407
            </a>.</span>
    </p></div><div class="sect1" title="14.2.&nbsp;Spring Managed Context"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringContext"></a>14.2.&nbsp;Spring Managed Context</h2></div></div></div><p>
        It's often desired to access Spring managed beans, to apply bean properties or to apply factory callbacks
        such as <code class="code">ApplicationContextAware</code>, <code class="code">BeanNameAware</code> or to apply bean post-processing
        such as <code class="code">InitializingBean</code>, <code class="code">@PostConstruct</code> like annotations
        while using Hazelcast distributed <code class="code">ExecutorService</code> or <code class="code">DistributedTask</code>s or more
        generally any Hazelcast managed object. Achieving those features are as simple as adding <code class="code">@SpringAware</code>
        annotation to your distributed object types. Once you have configured HazelcastInstance as explained in
        Spring configuration,
        just mark any distributed type with <code class="code">@SpringAware</code> annotation.

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;beans</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans"</font>
       <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font>
       <font font-style="bold" color="#0A1777">xmlns:context</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/context"</font>
       <font font-style="bold" color="#0A1777">xmlns:hz</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/spring"</font>
       <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		        http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context-3.0.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring-2.4.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;context:annotation-config /&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:group</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dev"</font> <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"password"</font><font font-style="bold" color="#0A1777">/&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:network</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"5701"</font> <font font-style="bold" color="#0A1777">port-auto-increment</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:join&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                        <font font-style="bold" color="#0A1777">&lt;hz:members&gt;</font>10.10.1.2, 10.10.1.3<font font-style="bold" color="#0A1777">&lt;/hz:members&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;/hz:tcp-ip&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/hz:join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/hz:network&gt;</font>
            ...
        <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"someBean"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.spring.SomeBean"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/beans&gt;</font>
</pre><p>

    <span class="bold"><strong>ExecutorService example:</strong></span>

    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@SpringAware</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeTask <strong class="hl-keyword">implements</strong> Callable&lt;Long&gt;, ApplicationContextAware, Serializable {

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> ApplicationContext context;

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> SomeBean someBean;

    <strong class="hl-keyword">public</strong> Long call() <strong class="hl-keyword">throws</strong> Exception {
        <strong class="hl-keyword">return</strong> someBean.value;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setApplicationContext(<strong class="hl-keyword">final</strong> ApplicationContext applicationContext)
        <strong class="hl-keyword">throws</strong> BeansException {
        context = applicationContext;
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setSomeBean(<strong class="hl-keyword">final</strong> SomeBean someBean) {
        <strong class="hl-keyword">this</strong>.someBean = someBean;
    }
}
</pre><p>

   </p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
SomeBean bean = (SomeBean) context.getBean(<font font-style="normal" color="#008000">"someBean"</font>);

Future&lt;Long&gt; f = hazelcast.getExecutorService().submit(<strong class="hl-keyword">new</strong> SomeTask());
Assert.assertEquals(bean.value, f.get().longValue());

<em class="hl-comment" style="color: silver">// choose a member</em>
Member member = hazelcast.getCluster().getMembers().iterator().next();

Future&lt;Long&gt; f2 = (Future&lt;Long&gt;) hazelcast.getExecutorService()
    .submit(<strong class="hl-keyword">new</strong> DistributedTask&lt;Long&gt;(<strong class="hl-keyword">new</strong> SomeTask(), member));
Assert.assertEquals(bean.value, f2.get().longValue());

</pre><p>


    <span class="bold"><strong>Distributed Map value example:</strong></span>

    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@SpringAware</span></em>
<em><span class="hl-annotation" style="color: gray">@Component("someValue")</span></em>
<em><span class="hl-annotation" style="color: gray">@Scope("prototype")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeValue <strong class="hl-keyword">implements</strong> Serializable, ApplicationContextAware {

    <strong class="hl-keyword">transient</strong> ApplicationContext context;

    <strong class="hl-keyword">transient</strong> SomeBean someBean;

    <strong class="hl-keyword">transient</strong> <strong class="hl-keyword">boolean</strong> init = false;

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setApplicationContext(<strong class="hl-keyword">final</strong> ApplicationContext applicationContext)
        <strong class="hl-keyword">throws</strong> BeansException {
        context = applicationContext;
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setSomeBean(<strong class="hl-keyword">final</strong> SomeBean someBean) {
        <strong class="hl-keyword">this</strong>.someBean = someBean;
    }

    <em><span class="hl-annotation" style="color: gray">@PostConstruct</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init() {
        someBean.doSomethingUseful();
        init = true;
    }
    ...
}
</pre><p>

   On Node-1;
</p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
SomeValue value = (SomeValue) context.getBean(<font font-style="normal" color="#008000">"someValue"</font>)
IMap&lt;String, SomeValue&gt; map = hazelcast.getMap(<font font-style="normal" color="#008000">"values"</font>);
map.put(<font font-style="normal" color="#008000">"key"</font>, value);
</pre><p>

    On Node-2;
    </p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
IMap&lt;String, SomeValue&gt; map = hazelcast.getMap(<font font-style="normal" color="#008000">"values"</font>);
SomeValue value = map.get(<font font-style="normal" color="#008000">"key"</font>);
Assert.assertTrue(value.init);
</pre><p>
        <span class="italic">Note that, Spring managed properties/fields are marked as <code class="code">transient</code>.</span>
    </p></div><div class="sect1" title="14.3.&nbsp;Spring Cache"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringCache"></a>14.3.&nbsp;Spring Cache</h2></div></div></div><p>
        As of version 3.1, Spring Framework provides support for adding caching into an existing Spring application.
        To use Hazelcast as Spring cache provider, you should just define a <code class="code">com.hazelcast.spring.cache.HazelcastCacheManager</code>
        bean and register it as Spring cache manager.

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;cache:annotation-driven</font> <font font-style="bold" color="#0A1777">cache-manager</font>=<font font-style="bold" color="#008000">"cacheManager"</font><font font-style="bold" color="#0A1777"> /&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"hazelcast"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"cacheManager"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.cache.HazelcastCacheManager"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="_top">
            Spring Cache Abstraction
        </a>.</span>
    </p></div><div class="sect1" title="14.4.&nbsp;Hibernate 2nd Level Cache Config"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringHibernate"></a>14.4.&nbsp;Hibernate 2nd Level Cache Config</h2></div></div></div><p>
    If you are using Hibernate with Hazelcast as 2nd level cache provider, you
    can easily create
    <code class="code">CacheProvider</code>
    or
    <code class="code">RegionFactory</code>
    instances within
    Spring configuration. That way it is possible to use same
    <code class="code">HazelcastInstance</code>
    as Hibernate L2
    cache instance.
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:hibernate-cache-provider</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"cacheProvider"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
...

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"sessionFactory"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dataSource"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"cacheProvider"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"cacheProvider"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
    Or by Spring version 3.1
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:hibernate-region-factory</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"regionFactory"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"sessionFactory"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dataSource"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"cacheRegionFactory"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"regionFactory"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
        </p></div><div class="sect1" title="14.5.&nbsp;Spring Data - JPA"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringJPA"></a>14.5.&nbsp;Spring Data - JPA</h2></div></div></div><p>
        Hazelcast supports JPA persistence integrated with <a class="link" href="http://www.springsource.org/spring-data/jpa" target="_top">
        Spring Data-JPA</a> module.
        Your POJOs are mapped and persisted to your relational database.
        To use JPA persistence first you should create a Repository interface extending CrudRepository class with object type that you want to persist..
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.jpa.repository;

<strong class="hl-keyword">import</strong> com.hazelcast.jpa.Product;
<strong class="hl-keyword">import</strong> org.springframework.data.repository.CrudRepository;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> ProductRepository <strong class="hl-keyword">extends</strong> CrudRepository&lt;Product, Long&gt; {

}
</pre><p>
        Then you should add your data source and repository definition to you Spring configuration,
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;jpa:repositories</font>
       <font font-style="bold" color="#0A1777">base-package</font>=<font font-style="bold" color="#008000">"com.hazelcast.jpa.repository"</font><font font-style="bold" color="#0A1777"> /&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.jpa.SpringJPAMapStore"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"jpamapstore"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"crudRepository"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"productRepository"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.apache.commons.dbcp.BasicDataSource"</font> <font font-style="bold" color="#0A1777">destroy-method</font>=<font font-style="bold" color="#008000">"close"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"driverClassName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"com.mysql.jdbc.Driver"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"url"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"jdbc:mysql://localhost:3306/YOUR_DB"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"username"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"YOUR_USERNAME"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"password"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"YOUR_PASSWORD"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font>
      <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</font><font font-style="bold" color="#0A1777">&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dataSource"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpaVendorAdapter"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</font><font font-style="bold" color="#0A1777">&gt;</font>
          <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"generateDdl"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
          <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"database"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"MYSQL"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"persistenceUnitName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"jpa.sample"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.JpaTransactionManager"</font>
      <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"transactionManager"</font><font font-style="bold" color="#0A1777">&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font>
          <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpaDialect"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.vendor.HibernateJpaDialect"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
    </pre><p>
    In the example configuration above, Hibernate and MYSQL is configured,
        you change them according your ORM and database selection.
        Also you should define your persistence unit with persistence.xml under META-INF directory.

        </p><pre class="programlisting">
<span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<font font-style="bold" color="#0A1777">&lt;persistence</font> <font font-style="bold" color="#0A1777">version</font>=<font font-style="bold" color="#008000">"2.0"</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://java.sun.com/xml/ns/persistence"</font> <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>
	<font font-style="bold" color="#0A1777">&lt;persistence-unit</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpa.sample"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/persistence&gt;</font>
</pre><p>

        By default, the key is expected to be the same with id of the JPA object. You can change this behaviour and customize MapStore implementation extending SpringJPAMapStore class.

    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/" target="_top">
            Spring Data JPA Reference
        </a>.</span>
    </p></div><div class="sect1" title="14.6.&nbsp;Spring Data - MongoDB"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringMongoDB"></a>14.6.&nbsp;Spring Data - MongoDB</h2></div></div></div><p>
        With version 2.1, Hazelcast will support MongoDB persistence integrated with <a class="link" href="http://www.springsource.org/spring-data/mongodb" target="_top">
        Spring Data-MongoDB</a> module.
        Spring MongoDB module maps your objects to equivalent MongoDB objects.
        To persist your objects into MongoDB you should define MongoDB mapstore in your Spring configuration as follows:
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;mongo:mongo</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongo"</font> <font font-style="bold" color="#0A1777">host</font>=<font font-style="bold" color="#008000">"localhost"</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"27017"</font><font font-style="bold" color="#0A1777">/&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font>
      <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.data.mongodb.core.MongoTemplate"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"mongo"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"databaseName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"test"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.mongodb.MongoMapStore"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongomapstore"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
        Then you can set this as mapstore for maps that you want to persist into MongoDB.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"user"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"mongomapstore"</font>
                  <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map-store&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>
</pre><p>
        By default, the key is set as id of the MongoDB object. You can override MongoMapStore class for you custom needs.

    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring-data/data-mongodb/docs/current/reference/html/" target="_top">
            Spring Data MongoDB Reference
        </a>.</span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;15.&nbsp;Clients"><div class="titlepage"><div><div><h2 class="title"><a name="Clients"></a>Chapter&nbsp;15.&nbsp;Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#NativeClient">15.1. Native Client</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JavaClient">15.1.1. Java Client</a></span></dt><dt><span class="sect2"><a href="#CSharpClient">15.1.2. CSharp Client <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="sect1"><a href="#MemcacheClient">15.2. Memcache Client</a></span></dt><dt><span class="sect1"><a href="#RestClient">15.3. Rest Client</a></span></dt></dl></div><p>

    There are currently three ways to connect to a running Hazelcast cluster:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <a class="link" href="#NativeClient" title="15.1.&nbsp;Native Client">Native Clients</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MemcacheClient" title="15.2.&nbsp;Memcache Client">Memcache Clients</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#RestClient" title="15.3.&nbsp;Rest Client">REST Client</a>
            </p></li></ol></div><p>
</p><div class="sect1" title="15.1.&nbsp;Native Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NativeClient"></a>15.1.&nbsp;Native Client</h2></div></div></div><p>Native Client enables you to do all Hazelcast operations without being a member of the
        cluster. It connects to one of the cluster members and delegates all cluster wide operations
        to it. When the relied cluster member dies, client will transparently switch to another live
        member.
    </p><p>There can be hundreds, even thousands of clients connected to the cluster. But by default there is 40 threads
    on server side that will handle all the requests. You may want to increase hazelcast.executor.client.thread.count
    property for better performance. </p><p>Imagine a trading application where all the trading data stored and managed in a 10 node
        Hazelcast cluster. Swing/Web applications at traders' desktops can use Native Java Client to
        access and modify the data in the Hazelcast cluster.
    </p><p>Currently Hazelcast has Native Java and C# Client available.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">
                LiteMember vs. Native Client
            </span>
        </strong></span>
    </p><p>LiteMember is a member of the cluster, it has socket connection to every member in the
        cluster and it knows where the data is so it will get to the data much faster. But LiteMember
        has the clustering overhead and it must be on the same data center even on the same
        RAC. However Native client is not member and relies on one of the cluster members. Native
        Clients can be anywhere in the LAN or WAN. It scales much better and overhead is quite less.
        So if your clients are less than Hazelcast nodes then LiteMember can be an option;
        otherwise definitely try Native Client. As a rule of thumb: Try Native client first, if it
        doesn't perform well enough for you, then consider LiteMember.
    </p><p>The following picture describes the clients connecting to Hazelcast Cluster. Note the
        difference between LiteMember and Java Client
        <span class="inlinemediaobject"><img src="http://www.hazelcast.com/resources/hazelcast-cluster-labels.png"></span>
    </p><div class="sect2" title="15.1.1.&nbsp;Java Client"><div class="titlepage"><div><div><h3 class="title"><a name="JavaClient"></a>15.1.1.&nbsp;Java Client</h3></div></div></div><p>You can do almost all hazelcast operations with Java Client. It already implements the
            same interface. You must include hazelcast-client.jar into your classpath.
            </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.HazelcastInstance;
<strong class="hl-keyword">import</strong> com.hazelcast.client.HazelcastClient;

<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Collection;


ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
clientConfig.getGroupConfig().setName(<font font-style="normal" color="#008000">"dev"</font>).setPassword(<font font-style="normal" color="#008000">"dev-pass"</font>);
clientConfig.addAddress(<font font-style="normal" color="#008000">"10.90.0.1"</font>, <font font-style="normal" color="#008000">"10.90.0.2:5702"</font>);

HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
<em class="hl-comment" style="color: silver">//All cluster operations that you can do with ordinary HazelcastInstance</em>
Map&lt;String, Customer&gt; mapCustomers = client.getMap(<font font-style="normal" color="#008000">"customers"</font>);
mapCustomers.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Joe"</font>, <font font-style="normal" color="#008000">"Smith"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"2"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Ali"</font>, <font font-style="normal" color="#008000">"Selam"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"3"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Avi"</font>, <font font-style="normal" color="#008000">"Noyan"</font>));

Collection&lt;Customer&gt; colCustomers = mapCustomers.values();
<strong class="hl-keyword">for</strong> (Customer customer : colCustomers) {
     <em class="hl-comment" style="color: silver">// process customer</em>
}
</pre><p>
        </p></div><div class="sect2" title="15.1.2.&nbsp;CSharp Client (Enterprise Edition Only)"><div class="titlepage"><div><div><h3 class="title"><a name="CSharpClient"></a>15.1.2.&nbsp;CSharp Client <sup>(Enterprise Edition Only)</sup></h3></div></div></div><p>You can use native C# client to connect to the running Hazelcast instances. All you need is to include
            Hazelcast.Client.dll into your C# project. The API is very similar to Java native client. Note that C# client
            doesn't have automatic reconnection feature. If the node that it connected dies, it will not switch to another member.
            User must connect to another member itself.
            </p><pre class="programlisting">

using System;
using System.Collections.Generic;

using Hazelcast.Client;
using Hazelcast.Core;

ClientConfig clientConfig = new ClientConfig();
clientConfig.GroupConfig.Name = "dev";
clientConfig.GroupConfig.Password = "dev-pass";
clientConfig.addAddress("10.90.0.1");

HazelcastClient client = HazelcastClient.newHazelcastClient(clientConfig);
//Allmost all cluster operations that you can do with ordinary HazelcastInstance
//Note that the Customer class must have Serializable attribute or implement Hazelcast.IO.DataSerializable
IMap&lt;String, Customer&gt; mapCustomers = client.getMap("customers");
mapCustomers.put("1", new Customer("Joe", "Smith"));
mapCustomers.put("2", new Customer("Ali", "Selam"));
mapCustomers.put("3", new Customer("Avi", "Noyan"));

ICollection&lt;Customer&gt; colCustomers = mapCustomers.values();
foreach (Customer customer in colCustomers) {
     // process customer
}
</pre><p>


        </p><p>
            You can serialize back and forth Java and C# Objects between C# client and Hazelcast server.
            All you need is to have your classes that you want to share to implement DataSerializable both on Java and C#
            in the exact same way. And on C# ClientConfig you must set a TypeConverter implementation that will convert
            Java Class name into C# Type and vice versa.

            A basic TypeConverter might look like this.
            </p><pre class="programlisting">

public class MyTypeConverter: Hazelcast.IO.ITypeConverter
{
    public string getJavaName(Type type)
    {
        if(type.Equals(typeof(Hazelcast.Client.Examples.MyCSharpClass)))
            return "com.hazelcast.examples.MyClass";

        return null;
    }

    public Type getType(String javaName)
    {
        if("com.hazelcast.examples.MyClass".Equals(javaName))
            return typeof(Hazelcast.Client.Examples.MyCSharpClass);

        return null;
    }
}

            </pre><p>

            A basic MyCSharpClass implementing DataSerializable

            </p><pre class="programlisting">

using System;
using Hazelcast.IO;

public class MyCSharpClass: Hazelcast.IO.DataSerializable
{
    String field1 = "";
    int field2;

    public MyCSharpClass ()
    {
    }

    public MyCSharpClass (String f1, int f2)
    {
        this.field1 = f1;
        this.field2 = f2;
    }

    public void writeData(IDataOutput dout){
        dout.writeUTF(field1);
        dout.writeInt(field2);
    }

    public void readData(IDataInput din){
        field1 = din.readUTF();
        field2 = din.readInt();
    }
}

            </pre><p>
        </p></div></div><div class="sect1" title="15.2.&nbsp;Memcache Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MemcacheClient"></a>15.2.&nbsp;Memcache Client</h2></div></div></div><p>A Memcache client written in any language can talk directly to Hazelcast cluster. No
        additional configuration is required. Here is an example: Let's say your cluster's members
        are:</p><pre class="programlisting">Members [<span class="hl-number">5</span>] {
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.1</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.2</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.4</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.3</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.5</span>:<span class="hl-number">5701</span>]
 }
</pre><p>And you have a PHP application that uses PHP Memcache client to cache things in
        Hazelcast. All you need to do is have your PHP memcache client connect to one of these
        members. It doesn't matter which member the client connects to because Hazelcast cluster
        looks as one giant machine (Single System Image). PHP client code sample:
</p><pre class="programlisting">&lt;?php
    $memcache = <strong class="hl-keyword">new</strong> Memcache;
    $memcache-&gt;connect(<font font-style="normal" color="#008000">'10.20.17.1'</font>, <span class="hl-number">5701</span>) or die (<font font-style="normal" color="#008000">"Could not connect"</font>);
    $memcache-&gt;set(<font font-style="normal" color="#008000">'key1'</font>,<font font-style="normal" color="#008000">'value1'</font>,<span class="hl-number">0</span>,<span class="hl-number">3600</span>);
    $get_result = $memcache-&gt;get(<font font-style="normal" color="#008000">'key1'</font>); <em class="hl-comment" style="color: silver">//retrieve your data</em>
    var_dump($get_result); <em class="hl-comment" style="color: silver">//show it</em>
?&gt;
</pre><p>Notice that memcache client is connecting to
        <code class="literal">10.20.17.1</code>
        and
        using port<code class="literal">5701</code>. Java client code sample with SpyMemcached client:
    </p><pre class="programlisting">
MemcachedClient client = <strong class="hl-keyword">new</strong> MemcachedClient(AddrUtil.getAddresses(<font font-style="normal" color="#008000">"10.20.17.1:5701 10.20.17.2:5701"</font>));
client.set(<font font-style="normal" color="#008000">"key1"</font>, <span class="hl-number">3600</span>, <font font-style="normal" color="#008000">"value1"</font>);
System.out.println(client.get(<font font-style="normal" color="#008000">"key1"</font>));
</pre><p>An entry written with a memcache client can be read by another memcache client
        written in another language.
    </p></div><div class="sect1" title="15.3.&nbsp;Rest Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RestClient"></a>15.3.&nbsp;Rest Client</h2></div></div></div><p>Let's say your cluster's members are:</p><pre class="programlisting">Members [<span class="hl-number">5</span>] {
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.1</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.2</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.4</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.3</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.5</span>:<span class="hl-number">5701</span>]
 }
</pre><p>And you have a distributed map named 'stocks'. You can put a new
        <code class="literal">key1/value1</code>
        entry into this map by issuing
        <code class="literal">HTTP
            POST
        </code>
        call to
        <code class="literal">http://10.20.17.1:5701/hazelcast/rest/maps/stocks/key1</code>
        URL. Your http post call's content body should contain the value (value1). You can
        retrieve this entry via
        <code class="literal">HTTP GET</code>
        call to
        <code class="literal">http://10.20.17.1:5701/hazelcast/rest/maps/stocks/key1</code>. You can also retrieve this
        entry from another member such
        as<code class="literal">http://10.20.17.3:5701/hazelcast/rest/maps/stocks/key1</code>.
    </p><p>RESTful access is provided through any member of your cluster. So you can even put an
        HTTP load-balancer in-front of your cluster members for load-balancing and
        fault-tolerance.
    </p><p>Now go ahead and install a REST plugin for your browser and explore further.</p><p>Hazelcast also stores the mime-type of your
        <code class="literal">POST</code>
        request if it
        contains any. So if, for example, you post binary of an image file and set the
        mime-type of the
        <code class="literal">HTTP POST</code>
        request to
        <code class="literal">image/jpeg</code>
        then this mime-type will be part of the
        response of your
        <code class="literal">HTTP GET</code>
        request for that entry.
    </p><p>Let's say you also have a task queue named 'tasks'. You can offer a new item into the
        queue via HTTP POST and take and item from the queue via HTTP DELETE.
    </p><p>
        <code class="code">HTTP POST http://10.20.17.1:5701/hazelcast/rest/queues/tasks &lt;CONTENT&gt;</code>
        means
        </p><pre class="programlisting">Hazelcast.getQueue(<font font-style="normal" color="#008000">"tasks"</font>).offer(&lt;CONTENT&gt;);
</pre><p>
        and
        <code class="code">HTTP DELETE http://10.20.17.1:5701/hazelcast/rest/queues/tasks/3</code>
        means
        </p><pre class="programlisting">Hazelcast.getQueue(<font font-style="normal" color="#008000">"tasks"</font>).poll(<span class="hl-number">3</span>, SECONDS);
</pre><p>
        Note that you will have to handle the failures on REST polls as there is no
        transactional guarantee.
    </p></div></div><div class="chapter" title="Chapter&nbsp;16.&nbsp;Internals"><div class="titlepage"><div><div><h2 class="title"><a name="Internals"></a>Chapter&nbsp;16.&nbsp;Internals</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#InternalsSerialization">16.1. Internals 2: Serialization</a></span></dt><dt><span class="sect1"><a href="#InternalsClusterMembership">16.2. Internals 3: Cluster Membership</a></span></dt><dt><span class="sect1"><a href="#InternalsDistributedMap">16.3. Internals 4: Distributed Map</a></span></dt></dl></div><div class="sect1" title="16.1.&nbsp;Internals 2: Serialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="InternalsSerialization"></a>16.1.&nbsp;Internals 2: Serialization</h2></div></div></div><p>All your distributed objects such as your key and value objects, objects you offer into
        distributed queue and your distributed callable/runnable objects have to
        be<code class="literal">Serializable</code>.
    </p><p>Hazelcast serializes all your objects into an instance
        of<code class="literal">com.hazelcast.nio.Data</code>.
        <code class="literal">Data</code>
        is the binary
        representation of an object. When Hazelcast serializes an object into<code class="literal">Data</code>,
        it first checks whether the object is an instance of well-known, optimizable object
        such as<code class="literal">String, Long, Integer, byte[], ByteBuffer, Date</code>. If not, it then checks
        whether the object is an instance
        of<code class="literal">com.hazelcast.nio.DataSerializable</code>. If not, Hazelcast
        uses standard java serialization to convert the object into binary format. See
        <code class="literal">com.hazelcast.nio.Serializer</code>
        for details.
    </p><p>So for faster serialization, Hazelcast recommends to use of
        <code class="literal">String, Long,
            Integer, byte[]
        </code>
        objects or to implement
        <code class="literal">com.hazelcast.nio.DataSerializable</code>
        interface. Here is an
        example of a class implementing
        <code class="literal">com.hazelcast.nio.DataSerializable</code>
        interface.
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Address <strong class="hl-keyword">implements</strong> com.hazelcast.nio.DataSerializable {
    <strong class="hl-keyword">private</strong> String street;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> zipCode;
    <strong class="hl-keyword">private</strong> String city;
    <strong class="hl-keyword">private</strong> String state;

    <strong class="hl-keyword">public</strong> Address() {}

    <em class="hl-comment" style="color: silver">//getters setters..</em>

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> writeData(DataOutput out) <strong class="hl-keyword">throws</strong> IOException {
        out.writeUTF(street);
        out.writeInt(zipCode);
        out.writeUTF(city);
        out.writeUTF(state);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> readData (DataInput in) <strong class="hl-keyword">throws</strong> IOException {
        street    = in.readUTF();
        zipCode = in.readInt();
        city    = in.readUTF();
        state    = in.readUTF();
    }
}
</pre><p>
        Lets take a look at another example which is encapsulating a
        <code class="literal">DataSerializable</code>
        field.</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Employee <strong class="hl-keyword">implements</strong> com.hazelcast.nio.DataSerializable {
    <strong class="hl-keyword">private</strong> String firstName;
    <strong class="hl-keyword">private</strong> String lastName;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> age;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">double</strong> salary;
    <strong class="hl-keyword">private</strong> Address address; <em class="hl-comment" style="color: silver">//address itself is DataSerializable</em>

    <strong class="hl-keyword">public</strong> Employee() {}

    <em class="hl-comment" style="color: silver">//getters setters..</em>

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> writeData(DataOutput out) <strong class="hl-keyword">throws</strong> IOException {
        out.writeUTF(firstName);
        out.writeUTF(lastName);
        out.writeInt(age);
        out.writeDouble (salary);
        address.writeData (out);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> readData (DataInput in) <strong class="hl-keyword">throws</strong> IOException {
        firstName = in.readUTF();
        lastName  = in.readUTF();
        age       = in.readInt();
        salary       = in.readDouble();
        address   = <strong class="hl-keyword">new</strong> Address();
        <em class="hl-comment" style="color: silver">// since Address is DataSerializable let it read its own internal state</em>
        address.readData (in);
    }
}
</pre><p>As you can see, since
        <code class="literal">address</code>
        field itself
        is<code class="literal">DataSerializable</code>, it is calling
        <code class="literal">address.writeData(out)</code>
        when writing and
        <code class="literal">address.readData(in)</code>
        when reading.
    </p><p>
        <span class="bold"><strong>Caution:</strong></span>
        Hazelcast serialization is done on the user
        thread and it assumes that there will be only one object serialization at a time. So
        putting any Hazelcast operation that will require to serialize anything else will
        break the serialization. For Example: Putting</p><pre class="programlisting">Hazelcast.getMap(<font font-style="normal" color="#008000">"anyMap"</font>).put(<font font-style="normal" color="#008000">"key"</font>, <font font-style="normal" color="#008000">"dummy value"</font>);
</pre><p>line in readData or writeData methods will break the serialization. If you have
        to perform such an operation, at least it should be performed in another thread
        which will force the serialization to take on different thread.
    </p></div><div class="sect1" title="16.2.&nbsp;Internals 3: Cluster Membership"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="InternalsClusterMembership"></a>16.2.&nbsp;Internals 3: Cluster Membership</h2></div></div></div><p>It is important to note that Hazelcast is a peer to peer clustering so there is no
        'master' kind of server in Hazelcast. Every member in the cluster is equal and has the same
        rights and responsibilities.
    </p><p>When a node starts up, it will check to see if there is already a cluster in the network.
        There are two ways to find this out:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Multicast discovery: If multicast discovery is enabled (that is the defualt)
                    then the node will send a join request in the form of a multicast datagram
                    packet.
                </p></li><li class="listitem"><p>Unicast discovery: if multicast discovery is disabled and
                    <code class="literal">TCP/IP</code>
                    join is enabled then the node will try to connect
                    to he IPs defined in the
                    <code class="literal">hazelcast.xml</code>
                    configuration file. If
                    it can successfully connect to at least one node, then it will send a join
                    request through the
                    <code class="literal">TCP/IP</code>
                    connection.
                </p></li></ul></div><p>
        If there is no existing node, then the node will be the first member of the
        cluster. If multicast is enabled then it will start a multicast listener so that it can
        respond to incoming join requests. Otherwise it will listen for join request coming
        via<code class="literal">TCP/IP</code>.
    </p><p>If there is an existing cluster already, then the oldest member in the cluster will
        receive the join request and check if the request is for the right group. If so, the oldest
        member in the cluster will start the join process.
    </p><p>In the join process, the oldest member will:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>send the new member list to all members</p></li><li class="listitem"><p>tell members to sync data in order to balance the data load</p></li></ul></div><p>
        Every member in the cluster has the same member list in the same order.
        First member is the oldest member so if the oldest member dies, second member in the list
        becomes the first member in the list and the new oldest member.
    </p><p>See
        <code class="literal">com.hazelcast.impl.Node</code>
        and
        <code class="literal">com.hazelcast.impl.ClusterManager</code>
        for details.
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Q. If, let say 50+, nodes are trying to join
                the cluster at the same time, are they going to join the cluster one by
                one?
            </strong></span>
        </span>
    </p><p>No. As soon as the oldest member receives the first valid join request, it will wait 5
        seconds for others to join so that it can join multiple members in one shot. If there is no
        new node willing to join for the next 5 seconds, then oldest member will start the join
        process. If a member leaves the cluster though, because of a JVM crash for example, cluster
        will immediately take action and oldest member will start the data recovery process.
    </p></div><div class="sect1" title="16.3.&nbsp;Internals 4: Distributed Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="InternalsDistributedMap"></a>16.3.&nbsp;Internals 4: Distributed Map</h2></div></div></div><p>Hazelcast distributed map is a peer to peer, partitioned implementation so entries put
        into the map will be almost evenly partitioned onto the existing members. Entries are
        partitioned according to their keys.
    </p><p>Every key is owned by a member. So every key-aware operation, such as
        <code class="literal">put,
            remove, get
        </code>
        is routed to the member owning the key.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">
                Q. How does Hazelcast determine the owner of a key?
            </span>
        </strong></span>
    </p><p>Hazelcast creates fixed number of virtual partitions (blocks). Partition count is set to
        <code class="literal">271</code>
        by default. Each key falls into one of these partitions. Each
        partition is owned/managed by a member. Oldest member of the cluster will assign the
        ownerships of the partitions and let every member know who owns which partitions. So at any
        given time, each member knows the owner member of a each partition. Hazelcast will convert
        your key object to
        <code class="literal">com.hazelcast.nio.Data</code>
        then calculate the partition of
        the owner:<code class="literal">partition-of-the-key = hash(keyData) % PARTITION_COUNT</code>. Since
        each member(JVM) knows the owner of each partition, each member can find out which member
        owns the key.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">
                Q. Can I get the owner of a key?
            </span>
        </strong></span>
    </p><p>Yes. Use Partition API to get the partition that your key falls into and then get the
        owner of that partition. Note that owner of the partition can change over time as new
        members join or existing members leave the cluster.</p><pre class="programlisting">PartitionService partitionService = Hazelcast.getPartitionService();
Partition partition = partitionService.getPartition(key);
Member ownerMember = partition.getOwner();
</pre><p>Locally owned entries can be obtained by
        calling<code class="literal">map.localKeySet()</code>.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">
                Q. What happens when a new member joins?
            </span>
        </strong></span>
    </p><p>Just like any other member in the cluster, the oldest member also knows who owns which
        partition and what the oldest member knows is always right. The oldest member is also
        responsible for redistributing the partition ownerships when a new member joins. Since there
        is new member, oldest member will take ownership of some of the partitions and give them to
        the new member. It will try to move the least amount of data possible. New ownership
        information of all partitions is then sent to all members.
    </p><p>Notice that the new ownership information may not reach each member at the same time and
        the cluster never stops responding to user map operations even during joins so if a member
        routes the operation to a wrong member, target member will tell the caller to
        <code class="literal">re-do</code>
        the operation.
    </p><p>If a member's partition is given to the new member, then the member will send all entries
        of that partition to the new member (Migrating the entries). Eventually every member in the
        cluster will own almost same number of partitions, and almost same number of entries. Also
        eventually every member will know the owner of each partition (and each key).
    </p><p>You can listen for migration events.
        <code class="literal">MigrationEvent</code>
        contains
        the<code class="literal">partitionId</code>,<code class="literal">oldOwner</code>, and
        <code class="literal">newOwner</code>
        information.
        </p><pre class="programlisting">PartitionService partitionService = Hazelcast.getPartitionService();
partitionService.addMigrationListener(<strong class="hl-keyword">new</strong> MigrationListener () {

   <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> migrationStarted(MigrationEvent migrationEvent) {
      System.out.println(migrationEvent);
   }

   <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> migrationCompleted(MigrationEvent migrationEvent) {
      System.out.println(migrationEvent);
   }
});
</pre><p>
        <span class="bold"><strong>
            <span class="italic">Q. How about distributed set and
                list?
            </span>
        </strong></span>
    </p><p>Both distributed set and list are implemented on top of distributed map. The underlying
        distributed map doesn't hold value; it only knows the key. Items added to both list and set
        are treated as keys. Unlike distributed set, since distributed list can have duplicate
        items, if an existing item is added again,
        <code class="literal">copyCount</code>
        of the entry
        (<code class="literal">com.hazelcast.impl.ConcurrentMapManager.Record</code>) is incremented. Also note that index
        based methods of distributed list, such as
        <code class="literal">List.get(index)</code>
        and<code class="literal">List.indexOf(Object)</code>, are not supported because it is too costly
        to keep distributed indexes of list items so it is not worth implementing.
    </p><p>Check out the
        <code class="literal">com.hazelcast.impl.ConcurrentMapManager</code>
        class for the
        implementation. As you will see, the implementation is lock-free because
        <code class="literal">ConcurrentMapManager</code>
        is a singleton and processed by only one thread,
        the<code class="literal">ServiceThread</code>.
    </p></div></div><div class="chapter" title="Chapter&nbsp;17.&nbsp;Management Center"><div class="titlepage"><div><div><h2 class="title"><a name="ManagementCenter"></a>Chapter&nbsp;17.&nbsp;Management Center</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#MC_Intro">17.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_Installation">17.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#MC_UserAdministration">17.1.2. User Administration</a></span></dt><dt><span class="sect2"><a href="#MC_ToolOverview">17.1.3. Tool Overview</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Maps">17.2. Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MapMonitoring">17.2.1. Monitoring Maps</a></span></dt><dt><span class="sect2"><a href="#MC_MapBrowser">17.2.2. Map Browser</a></span></dt><dt><span class="sect2"><a href="#MC_MapConfiguration">17.2.3. Map Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Queues">17.3. Queues</a></span></dt><dt><span class="sect1"><a href="#MC_Topics">17.4. Topics</a></span></dt><dt><span class="sect1"><a href="#MC_Members">17.5. Members</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MemberMonitoring">17.5.1. Monitoring</a></span></dt><dt><span class="sect2"><a href="#MC_MemberOperations">17.5.2. Operations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Logs">17.6. System Logs</a></span></dt><dt><span class="sect1"><a href="#MC_Scripting">17.7. Scripting</a></span></dt><dt><span class="sect1"><a href="#MC_TimeTravel">17.8. Time Travel</a></span></dt><dt><span class="sect1"><a href="#MC_Console">17.9. Console</a></span></dt></dl></div><div class="sect1" title="17.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Intro"></a>17.1.&nbsp;Introduction</h2></div></div></div><p>
        Hazelcast Management Center enables you to monitor and manage your servers running hazelcast.
        With Management Center, in addition to monitoring overall state of your clusters, you can also analyze
        and browse your data structures in details.
        You can also update map configurations and take thread dump from nodes.
        With its scripting module, you can run scritps (JavaScript, Groovy etc.) on your servers.
        Version 2.0 is a web based tool so you can deploy it into your internal server and serve your users.
    </p><div class="sect2" title="17.1.1.&nbsp;Installation"><div class="titlepage"><div><div><h3 class="title"><a name="MC_Installation"></a>17.1.1.&nbsp;Installation</h3></div></div></div><p>
            It is important to understand how it actually works. Basically you will deploy
            <code class="literal">mancenter.war</code>
            application into your Java web server and then tell
            Hazelcast nodes to talk to that web application. That means, your Hazelcast nodes should know the
            URL of
            <code class="literal">mancenter</code>
            application before they start.
        </p><p>Here are the steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download the latest Hazelcast zip from
                    <a class="link" href="http://www.hazelcast.com/downloads.jsp" target="_top">hazelcast.com</a>
                </p></li><li class="listitem"><p>
                    Zip contains
                    <code class="literal">mancenter.war</code>
                    file. Deploy it to your web server (Tomcat, Jetty etc.)
                    Let's say it is running at<code class="literal">http://localhost:8080/mancenter</code>.
                </p></li><li class="listitem"><p>Start your web server and make sure
                    <code class="literal">http://localhost:8080/mancenter</code>
                    is up.
                </p></li><li class="listitem"><p>Configure your Hazelcast nodes by adding the URL of your web app to your<code class="literal">
                    hazelcast.xml</code>.
                    Hazelcast nodes will send their states to this URL.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;management-center</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>http://localhost:8080/mancenter<font font-style="bold" color="#0A1777">&lt;/management-center&gt;</font></pre><p>
                </p></li><li class="listitem"><p>Start your hazelcast cluster.
                </p></li><li class="listitem"><p>Browse to
                    <code class="literal">http://localhost:8080/mancenter</code>
                    and login.
                    <span class="bold"><strong>
                        Initial login username/passwords is
                        <code class="literal">admin/admin</code>
                    </strong></span>
                </p></li></ul></div><p>
        <span class="emphasis"><em>Management Center creates a directory with name "mancenter" under your "user/home" directory to save data files.
                You can change the data directory setting "hazelcast.mancenter.home" system property.
        </em></span>
        </p></div><div class="sect2" title="17.1.2.&nbsp;User Administration"><div class="titlepage"><div><div><h3 class="title"><a name="MC_UserAdministration"></a>17.1.2.&nbsp;User Administration</h3></div></div></div><p>Default credentials are for the admin user. In the
            <code class="literal">Administration</code>
            tab,
            Admin can add/remove/update users and control user read/write permissions.
        </p><p>
            <span class="inlinemediaobject"><img src="images/admin.jpg" width="70%"></span>
        </p></div><div class="sect2" title="17.1.3.&nbsp;Tool Overview"><div class="titlepage"><div><div><h3 class="title"><a name="MC_ToolOverview"></a>17.1.3.&nbsp;Tool Overview</h3></div></div></div><p>The starter page of the tool is<code class="literal">Cluster Home</code>. Here you can see cluster's main properties
            such as uptime,
            memory. Also with pie chart, you can see the distribution of partitions over cluster members. You can come
            back to this page, by clicking the
            <code class="literal">Home</code>
            icon on the top-right toolbar.
            On the left panel you see the Map/Queue/Topic instances in the cluster. At the bottom-left corner, members
            of the cluster are listed.
            On top menu bar, you can change the current tab to<code class="literal">Scripting, Docs</code>,
            user<code class="literal">Administration</code>. Note that Administration tab is viewable only for admin users.
            Also
            <code class="literal">Scripting</code>
            page is disabled for users with read-only credential.
        </p><p>
            <span class="inlinemediaobject"><img src="images/clusterhome.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="17.2.&nbsp;Maps"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Maps"></a>17.2.&nbsp;Maps</h2></div></div></div><p>
        Map instances are listed on the left panel. When you click on a map, a new tab for monitoring this map instance
        is opened on the right.
        In this tab, you can monitor metrics also re-configure the map.
    </p><p>
        <span class="inlinemediaobject"><img src="images/maphome.jpg" width="70%"></span>
    </p><div class="sect2" title="17.2.1.&nbsp;Monitoring Maps"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapMonitoring"></a>17.2.1.&nbsp;Monitoring Maps</h3></div></div></div><p>
            In map page you can monitor instance metrics by 2 charts and 2 datatables. First data table "Memory Data
            Table" gives the memory metrics distributed over members. "Throughput Data Table" gives information about
            the operations performed on instance (get, put, remove)
            Each chart monitors a type data of the instance on cluster. You can change the type by clicking on chart.
            The possible ones are: Size, Throughput, Memory, Backup Size, Backup Memory, Hits, Locked Entries, Puts,
            Gets, Removes...
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapchart.jpg" width="70%"></span>
        </p></div><div class="sect2" title="17.2.2.&nbsp;Map Browser"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapBrowser"></a>17.2.2.&nbsp;Map Browser</h3></div></div></div><p>
            You can open "Map Browser" tool by clicking "Browse" button on map tab page. Using map browser, you can
            reach map's entries by keys. Besides its value, extra informations such as entry's cost, expiration time is
            provided.
        </p><p>
            <a class="link" href="images/mapbrowse.jpg" target="_top">
                <span class="inlinemediaobject"><img src="images/mapbrowse.jpg" width="70%"></span>
            </a>
        </p></div><div class="sect2" title="17.2.3.&nbsp;Map Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapConfiguration"></a>17.2.3.&nbsp;Map Configuration</h3></div></div></div><p>
            You can open "Map Configuration" tool by clicking "Config" button on map tab page. This button is disabled
            for users with Read-Only permission. Using map config tool you can adjust map's setting. You can change
            backup count, max size, max idle(seconds), eviction policy, cache value, read backup data, backup count of
            the map.
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapconfig.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="17.3.&nbsp;Queues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Queues"></a>17.3.&nbsp;Queues</h2></div></div></div><p>
        Queues is the second data structure that you can monitor in management center. You can activate the Queue Tab by
        clicking the instance name listed on the left panel under queues part. The queue page consists of the charts
        monitoring data about the queue. You can change the data to be monitored by clicking on the chart. Available
        options are Size, Polls, Offers.
    </p><p>
        <span class="inlinemediaobject"><img src="images/queue.jpg" width="70%"></span>
    </p></div><div class="sect1" title="17.4.&nbsp;Topics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Topics"></a>17.4.&nbsp;Topics</h2></div></div></div><p>
        You can monitor your topics' metrics by clicking the topic name listed on the left panel under topics part.
        There are two charts which reflects live data, and a datatable lists the live data distributed among members.
    </p><p>
        <span class="inlinemediaobject"><img src="images/topic.jpg" width="70%"></span>
    </p></div><div class="sect1" title="17.5.&nbsp;Members"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Members"></a>17.5.&nbsp;Members</h2></div></div></div><p>
        The current members in the cluster are listed on the bottom side of the left panel. You can monitor each member
        on tab page displayed by clicking on member items.
    </p><p>
        <span class="inlinemediaobject"><img src="images/member.jpg" width="70%"></span>
    </p><div class="sect2" title="17.5.1.&nbsp;Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MemberMonitoring"></a>17.5.1.&nbsp;Monitoring</h3></div></div></div><p>
            In members page there are 4 inner tab pages to monitor meber's state and properties.
            Runtime: Runtime properties about memory, threads are given. This data updates dynamically.
            Properties: System properties are displayed.
            Configuration: Configuration xml initially set can be viewed here.
            Partitions: The partitions belongs to this member are listed.
        </p><p>
            <span class="inlinemediaobject"><img src="images/memberconf.jpg" width="70%"></span>
        </p></div><div class="sect2" title="17.5.2.&nbsp;Operations"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MemberOperations"></a>17.5.2.&nbsp;Operations</h3></div></div></div><p>
            Besides monitoring you can perform certain actions on members.
            You can take thread dump of the member and you can perform garbage collection on the selected member.
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapoperations.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="17.6.&nbsp;System Logs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Logs"></a>17.6.&nbsp;System Logs</h2></div></div></div><p>
        System logs part helps you track internal operations and detect problems.
        To see system logs first you should set a Log level other than "None".
        In left menu there are inputs by which you can filter the displayed logs dynamically.
        Also you can Export your logs and send the file to Hazelcast support team, so they can analyze and help you solving your problem.
    </p><p>
        <span class="inlinemediaobject"><img src="images/systemlogs.jpg" width="70%"></span>
    </p></div><div class="sect1" title="17.7.&nbsp;Scripting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Scripting"></a>17.7.&nbsp;Scripting</h2></div></div></div><p>
        In scripting part, you can execute your own code on your cluster.
        In the left part you can select members, on which the code will be executed.
        Also you can select over scripting languages: Javascript, Groovy, JRuby, BeanShell.
        This part is only enabled for users with read/write permissions for current cluster.
    </p><p>
        <span class="inlinemediaobject"><img src="images/scripting.jpg" width="70%"></span>
    </p></div><div class="sect1" title="17.8.&nbsp;Time Travel"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_TimeTravel"></a>17.8.&nbsp;Time Travel</h2></div></div></div><p>
        Time Travel mode is activated by clicking clock icon on top right toolbar.
        In time travel mode,
        the time is paused and the full state of the cluster
        is displayed according the time selected on time slider.
        You can change time either by Prev/Next buttons or sliding the slider.
        Also you can change the day by clicking calendar icon.
        Management center stores the states in you local disk, while your web
        server is alive. So if you slide to a time when you do not have data,
        the reports will be seen as empty.
    </p><p>
        <span class="inlinemediaobject"><img src="images/timetravel.jpg" width="70%"></span>
    </p></div><div class="sect1" title="17.9.&nbsp;Console"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Console"></a>17.9.&nbsp;Console</h2></div></div></div><p>
        The console tool enables you execute commands on the cluster.
        You can read or write on instances but first you should set namespace.
        For example if you have a map with name "mapCustomers".
        To get a customer with key "Jack" you should first set the namespace with command "ns mapCustomers".
        Then you can take the object by "m.get Jack"
        Here is the command list:
        </p><pre class="programlisting">
-- General commands
echo true|false                      //turns on/off echo of commands (default false)
silent true|false                    //turns on/off silent of command output (default false)
#<font font-style="bold" color="#0A1777">&lt;number&gt;</font> <font font-style="bold" color="#0A1777">&lt;command&gt;</font>                  //repeats <font font-style="bold" color="#0A1777">&lt;number&gt;</font> time <font font-style="bold" color="#0A1777">&lt;command&gt;</font>, replace $i in <font font-style="bold" color="#0A1777">&lt;command&gt;</font> with current iteration (0..<font font-style="bold" color="#0A1777">&lt;number-1&gt;</font>)
&amp;<font font-style="bold" color="#0A1777">&lt;number&gt;</font> <font font-style="bold" color="#0A1777">&lt;command&gt;</font>                  //forks <font font-style="bold" color="#0A1777">&lt;number&gt;</font> threads to execute <font font-style="bold" color="#0A1777">&lt;command&gt;</font>, replace $t in <font font-style="bold" color="#0A1777">&lt;command&gt;</font> with current thread number (0..<font font-style="bold" color="#0A1777">&lt;number-1&gt;</font>
     When using #x or &amp;x, is is advised to use silent true as well.
     When using &amp;x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key index is specified
jvm                                  //displays info about the runtime
who                                  //displays info about the cluster
whoami                               //displays info about this cluster member
ns <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                          //switch the namespace for using the distributed queue/map/set/list <font font-style="bold" color="#0A1777">&lt;string&gt;</font> (defaults to "default"
@<font font-style="bold" color="#0A1777">&lt;file&gt;</font>                              //executes the given <font font-style="bold" color="#0A1777">&lt;file&gt;</font> script. Use '//' for comments in the script

-- Queue commands
q.offer <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                     //adds a string object to the queue
q.poll                               //takes an object from the queue
q.offermany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;size&gt;</font>]        //adds indicated number of string objects to the queue ('obj<font font-style="bold" color="#0A1777">&lt;i&gt;</font>' or byte[<font font-style="bold" color="#0A1777">&lt;size&gt;</font>])
q.pollmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                  //takes indicated number of objects from the queue
q.iterator [remove]                  //iterates the queue, remove if specified
q.size                               //size of the queue
q.clear                              //clears the queue

-- Set commands
s.add <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                       //adds a string object to the set
s.remove <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                    //removes the string object from the set
s.addmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                   //adds indicated number of string objects to the set ('obj<font font-style="bold" color="#0A1777">&lt;i&gt;</font>')
s.removemany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                //takes indicated number of objects from the set
s.iterator [remove]                  //iterates the set, removes if specified
s.size                               //size of the set
s.clear                              //clears the set

-- Lock commands
lock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                           //same as Hazelcast.getLock(key).lock()
tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                        //same as Hazelcast.getLock(key).tryLock()
tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;time&gt;</font>                 //same as tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> with timeout in seconds
unlock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                         //same as Hazelcast.getLock(key).unlock()

-- Map commands
m.put <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;value&gt;</font>                  //puts an entry to the map
m.remove <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                       //removes the entry of given key from the map
m.get <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                          //returns the value of given key from the map
m.putmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;size&gt;</font>] [<font font-style="bold" color="#0A1777">&lt;index&gt;</font>]//puts indicated number of entries to the map ('key<font font-style="bold" color="#0A1777">&lt;i&gt;</font>':byte[<font font-style="bold" color="#0A1777">&lt;size&gt;</font>], <font font-style="bold" color="#0A1777">&lt;index&gt;</font>+(0..<font font-style="bold" color="#0A1777">&lt;number&gt;</font>)
m.removemany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;index&gt;</font>]      //removes indicated number of entries from the map ('key<font font-style="bold" color="#0A1777">&lt;i&gt;</font>', <font font-style="bold" color="#0A1777">&lt;index&gt;</font>+(0..<font font-style="bold" color="#0A1777">&lt;number&gt;</font>)
     When using &amp;x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key <font font-style="bold" color="#0A1777">&lt;index&gt;</font> is specified
m.keys                               //iterates the keys of the map
m.values                             //iterates the values of the map
m.entries                            //iterates the entries of the map
m.iterator [remove]                  //iterates the keys of the map, remove if specified
m.size                               //size of the map
m.clear                              //clears the map
m.destroy                            //destroys the map
m.lock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                         //locks the key
m.tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                      //tries to lock the key and returns immediately
m.tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;time&gt;</font>               //tries to lock the key within given seconds
m.unlock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                       //unlocks the key

-- List commands:
l.add <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.add <font font-style="bold" color="#0A1777">&lt;index&gt;</font> <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.contains <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.remove <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.remove <font font-style="bold" color="#0A1777">&lt;index&gt;</font>
l.set <font font-style="bold" color="#0A1777">&lt;index&gt;</font> <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.iterator [remove]
l.size
l.clear
-- AtomicNumber commands:
a.get
a.set <font font-style="bold" color="#0A1777">&lt;long&gt;</font>
a.inc
a.dec
-- Executor Service commands:
execute	<font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font>				//executes an echo task on random member
execute0nKey	<font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> <font font-style="bold" color="#0A1777">&lt;key&gt;</font>		//executes an echo task on the member that owns the given key
execute0nMember <font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> <font font-style="bold" color="#0A1777">&lt;key&gt;</font>	//executes an echo task on the member with given index
execute0nMembers <font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> 		//executes an echo task on all of the members
</pre><p>
    </p><p>
        <span class="inlinemediaobject"><img src="images/console.jpg" width="70%"></span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;18.&nbsp;Miscellaneous"><div class="titlepage"><div><div><h2 class="title"><a name="Miscellaneous"></a>Chapter&nbsp;18.&nbsp;Miscellaneous</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CommonGotchas">18.1. Common Gotchas</a></span></dt><dt><span class="sect1"><a href="#ClusterTestHowTo">18.2. Testing Cluster</a></span></dt><dt><span class="sect1"><a href="#Todo">18.3. Planned Features</a></span></dt><dt><span class="sect1"><a href="#ReleaseNotes">18.4. Release Notes</a></span></dt></dl></div><div class="sect1" title="18.1.&nbsp;Common Gotchas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CommonGotchas"></a>18.1.&nbsp;Common Gotchas</h2></div></div></div><p>Hazelcast is the distributed implementation of several structures that exist in Java.
        Most of the time it behaves as you expect. However there are some design choices in
        Hazelcast that violate some contracts. This page will list those violations.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="bold"><strong>equals() and hashCode() methods for the objects stored
                        in Hazelcast
                    </strong></span>
                </p><p>When you store a key, value in a distributed Map, Hazelcast serializes the key
                    and value and stores the byte array version of them in local ConcurrentHashMaps.
                    And this ConcurrentHashMap uses the equals and hashCode methods of byte array
                    version of your key. So it does not take into account the actual equals and
                    hashCode implementations of your objects. So it is important that you choose
                    your keys in a proper way. Implementing the equals and hashCode is not enough,
                    it is also important that the object is always serialized into the same byte
                    array. All primitive types, like; String, Long, Integer and etc. are good
                    candidates for keys to use in Hazelcast. An unsorted Set is an example of a very
                    bad candidate because Java Serialization may serialize the same unsorted set in
                    two different byte arrays.
                </p><p>Note that the distributed Set and List stores its entries as the keys in a
                    distributed Map. So the notes above apply to the objects you store in Set and
                    List.
                </p></li><li class="listitem"><p>
                    Hazelcast always return a clone copy of a value. Modifying the returned value does not change
                    the actual value in the map (or multimap or list or set).
                    You should put modified value back to make changes visible to all nodes.
                    </p><pre class="programlisting">
V value = map.get(key);
value.updateSomeProperty();
map.put(key, value);
</pre><p>
                    If <code class="code">cache-value</code> is true (default is true), Hazelcast caches that returned value
                    for fast access in local node. Modifications done to this cached value without
                    putting it back to map will be visible to only local node, successive <code class="code">get</code> calls will
                    return the same cached value.
                    To reflect modifications to distributed map, you should put modified value back into map.
                </p></li><li class="listitem"><p>
                    Collections which return values of methods such as <code class="code">IMap.keySet</code>, <code class="code">IMap.values</code>,
                    <code class="code">IMap.entrySet</code>, <code class="code">MultiMap.get</code>, <code class="code">MultiMap.remove</code>,
                    <code class="code">IMap.keySet</code>, <code class="code">IMap.values</code>, contain cloned values. These collections are NOT
                    backup by related Hazelcast objects.
                    So changes to the these are <span class="bold"><strong>NOT</strong></span> reflected in the originals, and vice-versa.
                </p></li><li class="listitem"><p>
                    Most of the Hazelcast operations throw an <code class="code">RuntimeInterruptedException</code>
                    (which is unchecked version of <code class="code">InterruptedException</code>)
                    if a user thread is interrupted while waiting a response.
                    Hazelcast uses RuntimeInterruptedException to pass InterruptedException up through interfaces
                    that don't have InterruptedException in their signatures. Users should be able to catch and handle
                    <code class="code">RuntimeInterruptedException</code> in such cases as if their threads are interrupted on
                    a blocking operation.
                </p></li><li class="listitem"><p>
                    Some of Hazelcast operations can throw <code class="code">ConcurrentModificationException</code> under transaction
                    while trying to acquire a resource, although operation signatures don't define such an exception.
                    Exception is thrown if resource can not be acquired in a specific time. Users should be able to catch
                    and handle <code class="code">ConcurrentModificationException</code> while they are using Hazelcast transactions.
                </p></li></ol></div><p>
    </p></div><div class="sect1" title="18.2.&nbsp;Testing Cluster"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterTestHowTo"></a>18.2.&nbsp;Testing Cluster</h2></div></div></div><p>Hazelcast allows you to create more than one member on the same JVM. Each member is called
        <code class="literal">HazelcastInstance</code>
        and each will have its own configuration, socket
        and threads, so you can treat them as totally separate members. This enables us to write and
        run cluster unit tests on single JVM. As you can use this feature for creating separate
        members different applications running on the same JVM (imagine running multiple webapps on
        the same JVM), you can also use this feature for testing Hazelcast cluster.
    </p><p>Let's say you want to test if two members have the same size of a map.
        </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testTwoMemberMapSizes() {
    <em class="hl-comment" style="color: silver">// start the first member</em>
    HazelcastInstance h1 = Hazelcast.newHazelcastInstance(null);
    <em class="hl-comment" style="color: silver">// get the map and put 1000 entries</em>
    Map map1 = h1.getMap(<font font-style="normal" color="#008000">"testmap"</font>);
    <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; <span class="hl-number">1000</span>; i++) {
        map1.put(i, <font font-style="normal" color="#008000">"value"</font> + i);
    }
    <em class="hl-comment" style="color: silver">// check the map size</em>
    assertEquals(<span class="hl-number">1000</span>, map1.size());
    <em class="hl-comment" style="color: silver">// start the second member</em>
    HazelcastInstance h2 = Hazelcast.newHazelcastInstance(null);
    <em class="hl-comment" style="color: silver">// get the same map from the second member</em>
    Map map2 = h2.getMap(<font font-style="normal" color="#008000">"testmap"</font>);
    <em class="hl-comment" style="color: silver">// check the size of map2</em>
    assertEquals(<span class="hl-number">1000</span>, map2.size());
    <em class="hl-comment" style="color: silver">// check the size of map1 again</em>
    assertEquals(<span class="hl-number">1000</span>, map1.size());
}
</pre><p>In the test above, everything happened in the same thread. When developing
        multi-threaded test, coordination of the thread executions has to be carefully handled.
        Usage of
        <code class="literal">CountDownLatch</code>
        for thread coordination is highly recommended.
        You can certainly use other things. Here is an example where we need to listen for messages
        and make sure that we got these messages:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testTopic() {
    <em class="hl-comment" style="color: silver">// start two member cluster</em>
    HazelcastInstance h1 = Hazelcast.newHazelcastInstance(null);
    HazelcastInstance h2 = Hazelcast.newHazelcastInstance(null);
    String topicName = <font font-style="normal" color="#008000">"TestMessages"</font>;
    <em class="hl-comment" style="color: silver">// get a topic from the first member and add a messageListener</em>
    ITopic&lt;String&gt; topic1 = h1.getTopic(topicName);
    <strong class="hl-keyword">final</strong> CountDownLatch latch1 = <strong class="hl-keyword">new</strong> CountDownLatch(<span class="hl-number">1</span>);
    topic1.addMessageListener(<strong class="hl-keyword">new</strong> MessageListener() {
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(Object msg) {
            assertEquals(<font font-style="normal" color="#008000">"Test1"</font>, msg);
            latch1.countDown();
        }
    });
    <em class="hl-comment" style="color: silver">// get a topic from the second member and add a messageListener</em>
    ITopic&lt;String&gt; topic2 = h2.getTopic(topicName);
    <strong class="hl-keyword">final</strong> CountDownLatch latch2 = <strong class="hl-keyword">new</strong> CountDownLatch(<span class="hl-number">2</span>);
    topic2.addMessageListener(<strong class="hl-keyword">new</strong> MessageListener() {
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(Object msg) {
            assertEquals(<font font-style="normal" color="#008000">"Test1"</font>, msg);
            latch2.countDown();
        }
    });
    <em class="hl-comment" style="color: silver">// publish the first message, both should receive this</em>
    topic1.publish(<font font-style="normal" color="#008000">"Test1"</font>);
    <em class="hl-comment" style="color: silver">// shutdown the first member</em>
    h1.shutdown();
    <em class="hl-comment" style="color: silver">// publish the second message, second member's topic should receive this</em>
    topic2.publish(<font font-style="normal" color="#008000">"Test1"</font>);
    <strong class="hl-keyword">try</strong> {
        <em class="hl-comment" style="color: silver">// assert that the first member's topic got the message</em>
        assertTrue(latch1.await(<span class="hl-number">5</span>, TimeUnit.SECONDS));
        <em class="hl-comment" style="color: silver">// assert that the second members' topic got two messages</em>
        assertTrue(latch2.await(<span class="hl-number">5</span>, TimeUnit.SECONDS));
    } <strong class="hl-keyword">catch</strong> (InterruptedException ignored) {
    }
}
</pre><p>You can surely start Hazelcast members with different configuration. Let's say
        we want to test if Hazelcast
        <code class="literal">LiteMember</code>
        can shutdown fine.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test(timeout = 60000)</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> shutdownLiteMember() {
    <em class="hl-comment" style="color: silver">// first config for normal cluster member</em>
    Config c1 = <strong class="hl-keyword">new</strong> XmlConfigBuilder().build();
    c1.setPortAutoIncrement(false);
    c1.setPort(<span class="hl-number">5709</span>);
    <em class="hl-comment" style="color: silver">// second config for LiteMember</em>
    Config c2 = <strong class="hl-keyword">new</strong> XmlConfigBuilder().build();
    c2.setPortAutoIncrement(false);
    c2.setPort(<span class="hl-number">5710</span>);
    <em class="hl-comment" style="color: silver">// make sure to set LiteMember=true</em>
    c2.setLiteMember(true);
    <em class="hl-comment" style="color: silver">// start the normal member with c1</em>
    HazelcastInstance hNormal = Hazelcast.newHazelcastInstance(c1);
    <em class="hl-comment" style="color: silver">// start the LiteMember with different configuration c2</em>
    HazelcastInstance hLite = Hazelcast.newHazelcastInstance(c2);
    hNormal.getMap(<font font-style="normal" color="#008000">"default"</font>).put(<font font-style="normal" color="#008000">"1"</font>, <font font-style="normal" color="#008000">"first"</font>);
    assert hLite.getMap(<font font-style="normal" color="#008000">"default"</font>).get(<font font-style="normal" color="#008000">"1"</font>).equals(<font font-style="normal" color="#008000">"first"</font>);
    hNormal.shutdown();
    hLite.shutdown();
}
</pre><p>Also remember to call
        <code class="literal">Hazelcast.shutdownAll()</code>
        after each test
        case to make sure that there is no other running member left from the previous tests.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@After</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> cleanup() <strong class="hl-keyword">throws</strong> Exception {
    Hazelcast.shutdownAll();
}
</pre><p>Need more info?
        <a class="link" href="https://github.com/hazelcast/hazelcast/blob/master/hazelcast/src/test/java/com/hazelcast/impl/ClusterTest.java" target="_top">
            Check out existing tests.
        </a>
    </p></div><div class="sect1" title="18.3.&nbsp;Planned Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Todo"></a>18.3.&nbsp;Planned Features</h2></div></div></div><p>Random order of planned features.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Native C++ Client</p></li><li class="listitem"><p>Ready-to-go Hazelcast Cache Server Image for Amazon EC2</p></li><li class="listitem"><p>Symmetric Encryption and SSL support for Java Client</p></li><li class="listitem"><p>Continuous query (events based on given criteria)</p></li><li class="listitem"><p>Distributed
                    <code class="literal">java.util.concurrent.DelayQueue</code>
                    implementation.
                </p></li><li class="listitem"><p>Cluster-wide receive ordering for topics.</p></li><li class="listitem"><p>Distributed Tree implementation.</p></li><li class="listitem"><p>Distributed Tuple implementation.</p></li><li class="listitem"><p>Call interceptors for modifying the request or the response.</p></li><li class="listitem"><p>Built-in file based storage.</p></li></ul></div><p>
        History of existing features is available at<a class="link" href="#ReleaseNotes" title="18.4.&nbsp;Release Notes">Release Notes</a>.
    </p></div><div class="sect1" title="18.4.&nbsp;Release Notes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ReleaseNotes"></a>18.4.&nbsp;Release Notes</h2></div></div></div><p>Please see,
        <a class="link" href="#Todo" title="18.3.&nbsp;Planned Features">Todo</a>
        page for planned features.
    </p><p>
        <span class="bold"><strong>2.4</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Client threads is no longer fixed size,
                    now on it is going to use internal Hazelcast cached thread pool.
                </p></li><li class="listitem"><p>Added ability to restrict outbound ports that Hazelcast uses to connect other nodes.
                    See <a class="link" href="#OutboundPorts" title="12.2.9.&nbsp;Restricting Outbound Ports">OutboundPorts</a> documentation.
                </p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=15&amp;state=closed" target="_top">
                    Fixed issues:</a></p><p>168, 251, 260, 262, 267, 268, 269, 270, 274, 275, 276, 277, 279, 282, 284, 288, 290, 292, 301</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.3.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=13&amp;state=closed" target="_top">
                    Fixed issues:</a></p><p>256, 258</p></li><li class="listitem"><p>Changed
                    <a class="link" href="#hazelcast.partition.migration.interval">
                        <code class="code">hazelcast.partition.migration.interval</code>
                    </a>
                    value from 1 to 0.
                </p></li><li class="listitem"><p>
                    <code class="code">ILock.newCondition()</code> now throws <code class="code">UnsupportedOperationException</code>.
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.3</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Changed <a class="link" href="#hazelcast.max.operation.timeout">
                    <code class="code">hazelcast.max.operation.timeout</code></a> unit from <span class="emphasis"><em>seconds</em></span>
                     to <span class="emphasis"><em>milliseconds</em></span>.</p></li><li class="listitem"><p>Added <a class="link" href="#hazelcast.max.concurrent.operation.limit">
                    <code class="code">hazelcast.max.concurrent.operation.limit</code></a> parameter to be able to limit
                    number of concurrent operations can be submitted to Hazelcast.</p></li><li class="listitem"><p>
                    Added <a class="link" href="#hazelcast.backup.redo.enabled">
                        <code class="code">hazelcast.backup.redo.enabled</code></a> parameter to enable/disable redo for
                    backup operations.
                </p></li><li class="listitem"><p>Added <span class="emphasis"><em>MultiMap and Distributed ExecutorService statistics</em></span> to
                    <a class="link" href="http://hazelcast.com/mancenter.jsp" target="_top">Management Center</a> application.</p></li><li class="listitem"><p>
                    <code class="code">MigrationListener</code> has now an additional method to receive failed migration events;
                    <code class="code">void migrationFailed(MigrationEvent migrationEvent)</code>.
                </p></li><li class="listitem"><p>
                    <code class="code">ItemEvent</code> has now an additional method returning <code class="literal">Member</code> firing
                    that event; <code class="code">public Member getMember()</code>.
                </p></li><li class="listitem"><p>
                    Improved out of memory (OOM) error detection and handling. Now it is possible to register custom hook
                    when <code class="code">OutOfMemoryError</code> is thrown.
                    See <code class="code">Hazelcast.setOutOfMemoryHandler(OutOfMemoryHandler)</code> and <code class="code">OutOfMemoryHandler</code>
                    javadocs for additional details.
                </p></li><li class="listitem"><p>
                    Fixed some issues related to domain name handling and networking/join.
                </p></li><li class="listitem"><p>
                    During cluster merge after a network split-brain, merging side will now fire <code class="code">MERGING</code>
                    and <code class="code">MERGED</code> before and after <code class="code">RESTARTING</code> and <code class="code">RESTARTED</code>
                    <code class="code">LifecycleEvent</code>s.
                </p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=12&amp;state=closed" target="_top">
                    Fixed issues:</a></p><p>167, 182, 188, 209, 217, 218, 220, 222, 223, 225, 226, 227, 228, 229,
                    230, 233, 234, 235, 237, 241, 243, 244, 247, 250</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.2</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Improved redo logs and added max call/operation timeout. See configuration properties
                    <a class="link" href="#hazelcast.max.operation.timeout"><code class="code">hazelcast.max.operation.timeout</code></a>
                    and <a class="link" href="#hazelcast.redo.giveup.threshold"><code class="code">hazelcast.redo.giveup.threshold</code></a>
                    </p></li><li class="listitem"><p>Improved domain name handling; Hazelcast will use defined addresses/domain-names in
                TCP-IP Config as they are, without resolving an IP address.</p></li><li class="listitem"><p>Added <span class="emphasis"><em>Cluster Health Check</em></span> to
                    <a class="link" href="http://hazelcast.com/mancenter.jsp" target="_top">Management Center</a> application.</p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=5&amp;state=closed" target="_top">
                    Fixed issues:</a></p><p>39, 93, 152, 153, 163, 164, 169</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.1.3</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Fixed join and split brain issues. Improved domain name handling.</p></li><li class="listitem"><p>Fixed host aware partition group when all members are lite but one.</p></li><li class="listitem"><p>Fixed jmx management service dead-lock issue.</p></li><li class="listitem"><p>Fixed IMap replace-if-same and and remove-if-same concurrency issues.</p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=7&amp;state=closed" target="_top">Fixed issues:</a></p><p>176, 177, 179, 181, 183, 185, 186, 189, 195, 196, 198</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.1.2</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Fixed interruption handling to avoid dead-locks and inconsistency.
                    See configuration property <code class="code">hazelcast.force.throw.interrupted.exception</code>
                    in <a class="link" href="#ConfigurationProperties" title="12.6.&nbsp;Advanced Configuration Properties">ConfigurationProperties</a> page.</p></li><li class="listitem"><p>Replaced ExecutorService used by migration process with a custom one.</p></li><li class="listitem"><p>Fixed ExecutorService a memory leak during executor thread termination.</p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=6&amp;state=closed" target="_top">Fixed issues:</a></p><p>161, 174</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.1.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=4&amp;state=closed" target="_top">Fixed issues:</a></p><p>73, 142, 146, 148, 149, 153, 158, 162, 163, 164</p></li><li class="listitem"><p><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=3&amp;state=closed" target="_top">
                    Fixed issues from 2.0.4 branch:</a></p><p>96, 98, 131, 132, 135, 140, 166</p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="#IPv6" title="12.2.8.&nbsp;IPv6 Support">IPv6 Support</a>: Hazelcast now supports IPv6 addresses seamlessly.
                </p></li><li class="listitem"><p><a class="link" href="#MapBackup" title="2.3.1.&nbsp;Backups">Async backup support.</a>
                </p></li><li class="listitem"><p><a class="link" href="#SpringCache" title="14.3.&nbsp;Spring Cache">Spring Cache</a> support: Hazelcast can be used as
                    <a class="link" href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="_top">
                        Spring Cache
                    </a> provider.
                </p></li><li class="listitem"><p><a class="link" href="#SpringContext" title="14.2.&nbsp;Spring Managed Context">Spring Dependency Injection</a> support: Hazelcast can apply bean properties
                    or to apply factory callbacks such as <code class="code">ApplicationContextAware</code>, <code class="code">BeanNameAware</code>
                    or to apply bean post-processing such as <code class="code">InitializingBean</code>, <code class="code">@PostConstruct</code> like annotations
                    while using Hazelcast distributed <code class="code">ExecutorService</code> or <code class="code">DistributedTask</code>s or more
                    generally any Hazelcast managed object.
                </p></li><li class="listitem"><p>Persistence support with Spring-Data <a class="link" href="#SpringMongoDB" title="14.6.&nbsp;Spring Data - MongoDB">MongoDB</a>
                    and <a class="link" href="#SpringJPA" title="14.5.&nbsp;Spring Data - JPA">JPA</a> integration.
                </p></li><li class="listitem"><p>
                    <code class="literal">Member.getUuid()</code> will return UUID for node.
                </p></li><li class="listitem"><p><a class="link" href="#HttpSessionClustering" title="Chapter&nbsp;10.&nbsp;Http Session Clustering with HazelcastWM">Improved session clustering configuration.</a>
                </p></li><li class="listitem"><p>Fixed issues:

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p> <a class="link" href="http://code.google.com/p/hazelcast/issues/list" target="_top">Google Code</a></p><p>809, 811, 816, 818</p></li><li class="listitem"><p> <a class="link" href="https://github.com/hazelcast/hazelcast/issues" target="_top">Github</a></p><p>6, 7, 92, 98, 99, 101, 102, 103, 104, 108, 109, 110, 114, 116, 117, 118, 119, 120, 126, 127, 128,
                                130, 131, 132, 134, 135</p></li></ul></div><p>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>2.0</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>New Elastic Memory<sup>(Enterprise Edition Only)</sup>: By default, Hazelcast
                    stores your distributed data (map entries, queue items) into Java heap which is subject to garbage
                    collection. As your heap gets bigger, garbage collection might cause your application to pause tens
                    of seconds, badly effecting your application performance and response times. Elastic Memory is
                    Hazelcast with off-heap memory storage to avoid GC pauses. Even if you have terabytes of cache
                    in-memory with lots of updates, GC will have almost no effect; resulting in more predictable latency
                    and throughput.
                </p></li><li class="listitem"><p>Security Framework<sup>(Enterprise Edition Only)</sup>: Hazelcast Security is JAAS
                    based pluggable security framework which can be used to authenticate both cluster members and
                    clients and do access control checks on client operations. With the security framework, take control
                    of who can be part of the cluster or connect as client and which operations are allowed or not.
                </p></li><li class="listitem"><p>Native C# Client<sup>(Enterprise Edition Only)</sup>: Just like our Native Java
                    Client, it supports all map, multimap, queue, topic operations including listeners and queries.
                </p></li><li class="listitem"><p>Distributed Backups: Data owned by a member will be evenly backed up by all the other members. In
                    other word, every member takes equal responsibility to backup every other node. This leads to better
                    memory usage and less influence in the cluster when you add/remove nodes. The new backup system
                    makes it possible to form backup-groups so that you can have backups and owners fall into different
                    groups.
                </p></li><li class="listitem"><p>Parallel IO: Number of socket selector threads can be configured. You can have more IO threads, if
                    you have good number of CPU/cores and high-throughput network.
                </p></li><li class="listitem"><p>Connection Management: Hazelcast 2.0 is more tolerant to connection failures. On connection
                    failure it tries to repair it
                    before declaring the member as dead. So now it is ok to have short socket disconnections&#8230; No problem
                    if your virtual server migrates to a new host.
                </p></li><li class="listitem"><p>Listeners such as migration, membership and map indexes can be added with configuration.</p></li><li class="listitem"><p>New Event Objects: Event Listeners for Queue/List/Set/Topic were delivering the item itself on
                    event methods. That&#8217;s
                    why the items had to be deserialized by Hazelcast Threads before invoking the listeners. Sometimes
                    this was causing class loader problems too. With 2.0, we have introduced new event containers for
                    Queue/List/Set and Topic just like Map has EntryEvent. The new listeners now receive ItemEvent and
                    Message objects respectively. The actual items are deserialized only if you call the appropriate get
                    method on the event objects. This is where we brake the compatibility with the older versions of
                    Hazelcast.
                </p></li><li class="listitem"><p>ClientConfig API: We had too many of factory methods to instantiate a HazelcastClient. Now all we
                    need is<code class="literal">HazelcastClient.newHazelcastClient(ClientConfig)</code>.
                </p></li><li class="listitem"><p>SSL communication support among cluster nodes.
                </p></li><li class="listitem"><p>Distributed MultiMap value collection can be either List or Set.
                </p></li><li class="listitem"><p>SuperClient is renamed to LiteMember to avoid confusion. Be careful! It is a member, not a
                    client.
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.set (key, value, ttl, TimeUnit)</code>
                    implementation, which is optimized
                    <code class="literal">put(key, value)</code>
                    operation as set doesn&#8217;t return the old value.
                </p></li><li class="listitem"><p>
                    <code class="literal">HazelcastInstance.getLifecycleService().kill()</code>
                    will forcefully kill the node. Useful for testing.
                </p></li><li class="listitem"><p><code class="literal">forceUnlock</code>, to unlock the locked entry from any node and any thread regardless
                    of the owner.
                </p></li><li class="listitem"><p>Enum type query support..
                    <code class="literal">new SqlPredicate (&#8220;level = Level.WARNING&#8221;)</code>
                    for example
                </p></li><li class="listitem"><p>Fixed issues: 430, 459, 471, 567, 574, 582, 629, 632, 646, 666, 686, 669, 690, 692, 693, 695, 698,
                    705, 708,
                    710, 711, 712, 713, 714, 715, 719 , 721, 722, 724, 727, 728, 729, 730, 731, 732, 733, 735, 738, 739,
                    740, 741, 742, 747,
                    751, 752, 754, 756, 758, 759, 760, 761, 765, 767, 770, 773, 779, 781, 782, 783, 787, 790, 795, 796
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>1.9.4</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>New
                    <a class="link" href="#WanReplication" title="Chapter&nbsp;11.&nbsp;WAN Replication">WAN Replication</a>
                    (synchronization of separate active clusters)
                </p></li><li class="listitem"><p>New
                    <a class="link" href="#DataAffinity" title="Chapter&nbsp;5.&nbsp;Data Affinity">Data Affinity</a>
                    (co-location of related entries) feature.
                </p></li><li class="listitem"><p>New
                    <a class="link" href="#EC2AutoDiscovery" title="12.2.3.&nbsp;EC2 Auto Discovery">EC2 Auto Discovery</a>
                    for your Hazelcast cluster
                    running on Amazon EC2 platform.
                </p></li><li class="listitem"><p>New
                    <a class="link" href="http://www.hazelcast.com/docs/1.9.4/javadoc/com/hazelcast/core/ICountDownLatch.html" target="_top">
                        Distributed CountDownLatch implementation.
                    </a>
                </p></li><li class="listitem"><p>New
                    <a class="link" href="http://www.hazelcast.com/docs/1.9.4/javadoc/com/hazelcast/core/ISemaphore.html" target="_top">
                        Distributed Semaphore implementation.
                    </a>
                </p></li><li class="listitem"><p>Improvement: Distribution contains HTML and PDF documentation besides Javadoc.</p></li><li class="listitem"><p>Improvement: Better TCP/IP and multicast join support. Handling more edge cases like
                    multiple nodes starting at the same time.
                </p></li><li class="listitem"><p>Improvement: Memcache protocol: Better integration between Java and Memcache clients.
                    Put from memcache, get from Java client.
                </p></li><li class="listitem"><p>Monitoring Tool is removed from the project.</p></li><li class="listitem"><p>200+ commits 25+ bug fixes and several other enhancements.</p></li></ul></div><p>
        <span class="bold"><strong>1.9.3</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Re-implementation of distributed queue.
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Configurable backup-count and synchronous backup.</p></li><li class="listitem"><p>Persistence support based on backing MapStore</p></li><li class="listitem"><p>Auto-recovery from backing MapStore on startup.</p></li></ul></div><p>
                </p></li><li class="listitem"><p>Re-implementation of distributed list supporting index based operations.
                </p></li><li class="listitem"><p>New distributed semaphore implementation.</p></li><li class="listitem"><p>Optimized
                    <code class="literal">IMap.putAll</code>
                    for much faster bulk writes.
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.getAll</code>
                    for bulk reads which is calling
                    <code class="literal">MapLoader.loadAll</code>
                    if necessary.
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.tryLockAndGet</code>
                    and
                    <code class="literal">IMap.putAndUnlock</code>
                    API
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.putTransient</code>
                    API for storing only in-memory.
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.addLocalEntryListener()</code>
                    for listening locally
                    owned entry events.
                </p></li><li class="listitem"><p>New
                    <code class="literal">IMap.flush()</code>
                    for flushing the dirty entries into
                    MapStore.
                </p></li><li class="listitem"><p>New
                    <code class="literal">MapLoader.getAllKeys</code>
                    API for auto-pre-populating the
                    map when cluster starts.
                </p></li><li class="listitem"><p>Support for min. initial cluster size to enable equally partitioned start.
                </p></li><li class="listitem"><p>Graceful shutdown.</p></li><li class="listitem"><p>Faster dead-member detection.</p></li></ul></div><p>
        <span class="bold"><strong>1.9</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Memcache interface support. Memcache clients written in any language can
                    access Hazelcast cluster.
                </p></li><li class="listitem"><p>RESTful access support.
                    <code class="code">http://&lt;ip&gt;:5701/hazelcast/rest/maps/mymap/key1</code>
                </p></li><li class="listitem"><p>Split-brain (network partitioning) handling</p></li><li class="listitem"><p>New LifecycleService API to restart, pause Hazelcast instances and listen for
                    the lifecycle events.
                </p></li><li class="listitem"><p>New asynchronous put and get support for IMap via IMap.asyncPut() and
                    IMap.asyncGet()
                </p></li><li class="listitem"><p>New AtomicNumber API; distributed implementation of
                    java.util.concurrent.atomic.AtomicLong
                </p></li><li class="listitem"><p>So many bug fixes.</p></li></ul></div><p>
        <span class="bold"><strong>1.8.4</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Significant performance gain for multi-core servers. Higher CPU utilization
                    and lower latency.
                </p></li><li class="listitem"><p>Reduced the cost of map entries by 50%.</p></li><li class="listitem"><p>Better thread management. No more idle threads.</p></li><li class="listitem"><p>Queue Statistics API and the queue statistics panel on the Monitoring Tool.
                </p></li><li class="listitem"><p>Monitoring Tool enhancements. More responsive and robust.</p></li><li class="listitem"><p>Distribution contains hazelcast-all-&lt;version&gt;.jar to simplify jar
                    dependency.
                </p></li><li class="listitem"><p>So many bug fixes.</p></li></ul></div><p>
        <span class="bold"><strong>1.8.3</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Bug fixes</p></li><li class="listitem"><p>Sorted index optimization for map queries.</p></li></ul></div><p>
        <span class="bold"><strong>1.8.2</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A major bug fix</p></li><li class="listitem"><p>Minor optimizations</p></li></ul></div><p>
        <span class="bold"><strong>1.8.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Hazelcast Cluster Monitoring Tool (see the hazelcast-monitor-1.8.1.war in the
                    distro)
                </p></li><li class="listitem"><p>New Partition API. Partition and key owner, migration listeners.</p></li><li class="listitem"><p>New IMap.lockMap() API.</p></li><li class="listitem"><p>New Multicast+TCP/IP join feature. Try multicast first, if not found, try
                    tcp/ip.
                </p></li><li class="listitem"><p>New Hazelcast.getExecutorService(name) API. Have separate named
                    ExecutorServices. Do not let your big tasks blocking your small ones.
                </p></li><li class="listitem"><p>New Logging API. Build your own logging. or simply use Log4j or get logs as
                    LogEvents.
                </p></li><li class="listitem"><p>New MapStatistics API. Get statistics for your Map operations and entries.
                </p></li><li class="listitem"><p>HazelcastClient automatically updates the member list. no need to pass all
                    members.
                </p></li><li class="listitem"><p>Ability to start the cluster members evenly partitioned. so no migration.
                </p></li><li class="listitem"><p>So many bug fixes and enhancements.</p></li><li class="listitem"><p>There are some minor Config API change. Just make sure to re-compile.</p></li></ul></div><p>
        <span class="bold"><strong>1.8</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Java clients for accessing the cluster remotely. (C# is next)</p></li><li class="listitem"><p>Distributed Query for maps. Both Criteria API and SQL support.</p></li><li class="listitem"><p>Near cache for distributed maps.</p></li><li class="listitem"><p>TTL (time-to-live) for each individual map entry.</p></li><li class="listitem"><p>IMap.put(key,value, ttl, timeunit)</p></li><li class="listitem"><p>IMap.putIfAbsent(key,value, ttl, timeunit)</p></li><li class="listitem"><p>Many bug fixes.</p></li></ul></div><p>
        <span class="bold"><strong>1.7.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Multiple Hazelcast members on the same JVM. New
                    <code class="literal">HazelcastInstance</code>
                    API.
                </p></li><li class="listitem"><p>Better API based configuration support.</p></li><li class="listitem"><p>Many performance optimizations. Fastest Hazelcast ever!</p></li><li class="listitem"><p>Smoother data migration enables better response times during joins.</p></li><li class="listitem"><p>Many bug fixes.</p></li></ul></div><p>
        <span class="bold"><strong>1.7</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Persistence via Loader/Store interface for distributed map.</p></li><li class="listitem"><p>Socket level encryption. Both symmetric and asymmetric encryption supported.
                </p></li><li class="listitem"><p>New JMX support. (many thanks to Marco)</p></li><li class="listitem"><p>New Hibernate second level cache provider (many thanks to Leo)</p></li><li class="listitem"><p>Instance events for getting notified when a data structure instance (map,
                    queue, topic etc.) is created or destroyed.
                </p></li><li class="listitem"><p>Eviction listener.
                    <code class="literal">EntryListener.entryEvicted(EntryEvent)</code>
                </p></li><li class="listitem"><p>Fully 'maven'ized.</p></li><li class="listitem"><p>Modularized...</p></li><li class="listitem"><p>hazelcast (core library)</p></li><li class="listitem"><p>hazelcast-wm (http session clustering tool)</p></li><li class="listitem"><p>hazelcast-ra (JCA adaptor)</p></li><li class="listitem"><p>hazelcast-hibernate (hibernate cache provider)</p></li></ul></div><p>
        <span class="bold"><strong>1.6</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Support for synchronous backups and configurable backup-count for maps.
                </p></li><li class="listitem"><p>Eviction support. Timed eviction for queues. LRU, LFU and time based eviction
                    for maps.
                </p></li><li class="listitem"><p>Statistics/history for entries. create/update time, number of hits, cost. see
                    <code class="literal">IMap.getMapEntry(key)</code>
                </p></li><li class="listitem"><p>
                    <code class="literal">MultiMap</code>
                    implementation. similar to google-collections and
                    apache-common-collections
                    <code class="literal">MultiMap</code>
                    but distributed and
                    thread-safe.
                </p></li><li class="listitem"><p>Being able to
                    <code class="literal">destroy()</code>
                    the data structures when not needed
                    anymore.
                </p></li><li class="listitem"><p>Being able to Hazelcast.shutdown() the local member.</p></li><li class="listitem"><p>Get the list of all data structure instances
                    via<code class="literal">Hazelcast.getInstances()</code>.
                </p></li></ul></div><p>
        <span class="bold"><strong>1.5</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Major internal refactoring</p></li><li class="listitem"><p>Full implementation of<code class="literal">java.util.concurrent.BlockingQueue</code>.
                    Now queues can have configurable capacity limits.
                </p></li><li class="listitem"><p>Super Clients (a.k.a LiteMember): Members with no storage. If
                    <code class="literal">-Dhazelcast.super.client=true</code>
                    JVM parameter is set, that
                    JVM will join the cluster as a 'super client' which will not be a 'data
                    partition' (no data on that node) but will have super fast access to the cluster
                    just like any regular member does.
                </p></li><li class="listitem"><p>Http Session sharing support for Hazelcast Web Manager. Different webapps can
                    share the same sessions.
                </p></li><li class="listitem"><p>Ability to separate clusters by creating groups.
                    <a class="link" href="#ConfigGroup" title="12.1.&nbsp;Creating Separate Clusters">ConfigGroup</a>
                </p></li><li class="listitem"><p>
                    <code class="literal">java.util.logging</code>
                    support.
                </p></li></ul></div><p>
        <span class="bold"><strong>1.4</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add, remove and update events for queue, map, set and list</p></li><li class="listitem"><p>Distributed Topic for pub/sub messaging</p></li><li class="listitem"><p>Integration with J2EE transactions via JCA complaint resource adapter</p></li><li class="listitem"><p>
                    <a class="link" href="#ExecutionCallback" title="9.3.&nbsp;Execution Callback">ExecutionCallback</a>
                    interface for distributed tasks
                </p></li><li class="listitem"><p>Cluster-wide unique id generator</p></li></ul></div><p>
        <span class="bold"><strong>1.3</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Transactional Distributed Queue, Map, Set and List</p></li></ul></div><p>
        <span class="bold"><strong>1.2</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed Executor Service</p></li><li class="listitem"><p>Multi member executions</p></li><li class="listitem"><p>Key based execution routing</p></li><li class="listitem"><p>Task cancellation support</p></li></ul></div><p>
        <span class="bold"><strong>1.1</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Session Clustering with Hazelcast Webapp Manager</p></li><li class="listitem"><p>Full TCP/IP clustering support</p></li></ul></div><p>
        <span class="bold"><strong>1.0</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed implementation of java.util.{Queue,Map,Set,List}</p></li><li class="listitem"><p>Distributed implementation of java.util.concurrency.Lock</p></li><li class="listitem"><p>Cluster Membership Events</p></li></ul></div><p>
    </p></div></div></div></body></html>